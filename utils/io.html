<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>tssc.utils.io API documentation</title>
<meta name="description" content="Shared utilities for dealing with IO" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tssc.utils.io</code></h1>
</header>
<section id="section-intro">
<p>Shared utilities for dealing with IO</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Shared utilities for dealing with IO
&#34;&#34;&#34;

import io
import random
import re

def create_sh_redirect_to_multiple_streams_fn_callback(streams):
    &#34;&#34;&#34;Creates and returns a function callback that will write given data to multiple given streams.

    AKA: this essentially allows you to do &#39;tee&#39; for sh commands.

    Parameters
    ----------
    streams : list of io.IOBase
        Streams to write to.

    Examples
    --------
    Will write output directed at stdout to stdout and a results file and output directed
    at stderr to stderr and a results file.
    &gt;&gt;&gt; with open(&#39;/tmp/results_file&#39;, &#39;w&#39;) as results_file:
    ...     out_callback = create_sh_redirect_to_multiple_streams_fn_callback([
    ...         sys.stdout,
    ...         results_file
    ...     ])
    ...     err_callback = create_sh_redirect_to_multiple_streams_fn_callback([
    ...         sys.stderr,
    ...         results_file
    ...     ])
    ...     sh.echo(&#39;hello world&#39;)
    hello world

    Returns
    -------
    function(data)
        Function that takes one parameter, data, and writes that value to all the given streams.
    &#34;&#34;&#34;
    def sh_redirect_to_multiple_streams(data):
        for stream in streams:
            stream.write(data)

    return sh_redirect_to_multiple_streams

class TextIOSelectiveObfuscator(io.TextIOBase):
    &#34;&#34;&#34;Extends the base class for text streams to allow the obfuscation of given patterns.

    This is useful to prevent accidentally writing &#34;sensitive&#34; information to stdout/stderr.

    Parameters
    ----------
    parent_stream : IOBase
        IO stream to write to after obfuscating any text written to this stream.
    randomize_replacment_length : bool, optional
        True to randomize the length of the text being obfuscated in the stream.
        False to use the same length replacement for any obfuscated text in the stream.
    replacement_char : char
        Character to replace the target strings to obfuscate with.

    Attributes
    ----------
    __parent_stream : IOBase
    __obfuscation_paterns : list
    __replacement_char : char
    __randomize_replacment_length : bool
    __random_replacement_length_min : int
    __random_replacment_length_max : int
    &#34;&#34;&#34;

    def __init__(self, parent_stream, randomize_replacment_length=True, replacement_char=&#39;*&#39;):
        self.__parent_stream = parent_stream
        self.__obfuscation_paterns = []
        self.__replacement_char = replacement_char
        self.__randomize_replacment_length = randomize_replacment_length
        self.__random_replacement_length_min = 5
        self.__random_replacment_length_max = 40
        super().__init__()

    @property
    def parent_stream(self):
        &#34;&#34;&#34;
        Returns
        -------
        IOBase
            IO stream this stream writes to after obfuscating any text written to this stream.
        &#34;&#34;&#34;
        return self.__parent_stream

    @property
    def replacement_char(self):
        &#34;&#34;&#34;
        Returns
        -------
        char
            Character to replace the target strings to obfuscate with.
        &#34;&#34;&#34;
        return self.__replacement_char

    @replacement_char.setter
    def replacement_char(self, replacement_char):
        &#34;&#34;&#34;
        Parameters
        ----------
        replacement_char : char
            Character to replace the target strings to obfuscate with.
        &#34;&#34;&#34;
        self.__replacement_char = replacement_char

    @property
    def randomize_replacment_length(self):
        &#34;&#34;&#34;
        Returns
        -------
        bool
            True if this stream is randomizing the length of the text being obfuscated.
            False if this stream is using the same length replacement for any obfuscated text.
        &#34;&#34;&#34;
        return self.__randomize_replacment_length

    def add_obfuscation_targets(self, targets):
        &#34;&#34;&#34;Adds a target pattern to be obfuscated whenever writing to this stream.

        Notes
        -----
        This is a bit involved to deal with secrets that span multiple lines and various ways they
        can be printed. so the regex gets pretty involved to escape the right things and ignore
        whitespace, so forth and so on.

        There are unit tests covering the scenarios this is dealing with, if you are messing in
        here be sure you don&#39;t break any of the existing unit tests.

        Parameters
        ----------
        targets : list or pattern
            The target patterns to be obfuscated when writing to this stream.
        &#34;&#34;&#34;
        if not isinstance(targets, list):
            targets = [targets]

        for target in targets:
            target_pattern = target

            # replace any amount of whitespace with a single space
            target_pattern = re.sub(r&#39;\s+&#39;, &#39; &#39;, target_pattern)

            # strip off leading and trialing whitespace
            target_pattern = target_pattern.strip()

            # escape for use in regex pattern
            target_pattern = re.escape(target_pattern)

            # the spaces we added in now got escaped, so unescape them and turn them into .*
            target_pattern = re.sub(r&#39;\\ &#39;, r&#39;.*&#39;, target_pattern)

            # eat up pre and post newlines
            #target_pattern = f&#34;(\s*)({target_pattern})(\s*)&#34;

            # compile the pattern for re-use and make sure that .* matches accross lines
            target_compiled_pattern = re.compile(target_pattern, re.DOTALL)

            # add the pattern
            self.__obfuscation_paterns.append(target_compiled_pattern)

    def __obfuscator(self, match):
        &#34;&#34;&#34;Given a regex match returns a corresponding obfuscated string.

        Parameters
        ----------
        match : re.Match
            re.Match to replace with obfuscated text

        Returns
        -------
        str
            String to replace the given match with.

        Also See
        --------
        re.sub
        &#34;&#34;&#34;

        if self.randomize_replacment_length:
            replacment_length = random.randint(
                self.__random_replacement_length_min,
                self.__random_replacment_length_max
            )
        else:
            replacment_length = len(match.group())

        return self.replacement_char * replacment_length

    def write(self, given):
        &#34;&#34;&#34;Writes to this streams parent stream after obfuscating all of the obfuscation targets.

        Parameters
        ----------
        given : str
            Given string to write to the parent stream after obfuscating.

        Returns
        -------
        int
            Number of characters written.

        See Also
        --------
        io.TextIOBase.write
        &#34;&#34;&#34;

        if isinstance(given, bytes):
            obfuscated = given.decode(&#39;utf-8&#39;)
        else:
            obfuscated = given

        for obfuscation_pattern in self.__obfuscation_paterns:
            obfuscated = obfuscation_pattern.sub(self.__obfuscator, obfuscated)

        return self.parent_stream.write(obfuscated)

    def flush(self):
        &#34;&#34;&#34;Flush the parent stream.

        See Also
        --------
        io.TextIOBase.flush
        &#34;&#34;&#34;
        self.parent_stream.flush()

class TextIOIndenter(io.TextIOBase):
    &#34;&#34;&#34;Adds an indent to the first string written and after every new line written to this stream.

    Notes
    -----
    WARNING:    There will be a dangling indent after the last new line written to this stream
                because there is no &#34;good&#34; way of knowing the last new line ever written to this
                stream.

    Parameters
    ----------
    parent_stream : IOBase
        Stream to write to after indenting what is written to this stream
    indent_level : int, optional
        Level to indent to.
        Will be multiplied by the indent_size.
    indent_size : int, optional
        Size of each indent.
        Will be multipled by the indent_level.
    indent_char : str, optional
        Character to use for indent.
        Will be multiplied by the indent_size and the ident_level and prepended before
        each line written to this stream.
    &#34;&#34;&#34;

    def __init__(self, parent_stream, indent_level=0, indent_size=4, indent_char=&#39; &#39;):
        self.__parent_stream = parent_stream
        self.__indent_level = indent_level
        self.__indent_size = indent_size
        self.__indent_char = indent_char
        self.__unwritten_to = True
        super().__init__()

    @property
    def parent_stream(self):
        &#34;&#34;&#34;Returns parent stream that this stream wraps

        Returns
        -------
        IOBase
            Stream to write to after indenting what is written to this stream
        &#34;&#34;&#34;
        return self.__parent_stream

    @property
    def indent_level(self):
        &#34;&#34;&#34;Level to indent to.

        Returns
        -------
        int
            Level to indent to.
        &#34;&#34;&#34;
        return self.__indent_level

    @property
    def indent_size(self):
        &#34;&#34;&#34;Size of each indent.

        Returns
        -------
        int
            Size of each indent.
        &#34;&#34;&#34;
        return self.__indent_size

    @property
    def indent_char(self):
        &#34;&#34;&#34;Character to use for indent.

        Will be multiplied by the indent_size and the ident_level and prepended before
        each line written to this stream.

        Returns
        -------
        str
            Character to use for indent.
        &#34;&#34;&#34;
        return self.__indent_char

    def write(self, given):
        &#34;&#34;&#34;Indents the begining of the given text as well as every new line in the given text
        and then writes it to this steams parent_stream.

        Notes
        -----
        If there is a new line at the end of the given string there will not be an indent
        written after that new line assuming that the next line will be written by this stream
        and therefor get indented as being initially written to this stream.

        Parameters
        ----------
        given : str or bytes (utf-8)
            String to indent every line of before writing to parent stream.

        Examples
        --------
        &gt;&gt;&gt; TextIOIndenter(sys.stdout).write(&#34;hello world\\n&#34;)
        hello world
        &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&#34;hello world\\n&#34;)
            hello world
            &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&#34;hello world\\n&#34;)
                hello world
                &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout).write(&#34;\\nhello world\\n&#34;)
        &lt;BLANKLINE&gt;
        hello world
        &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&#34;\\nhello world\\n&#34;)
            &lt;BLANKLINE&gt;
            hello world
            &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&#34;\\nhello world\\n&#34;)
                &lt;BLANKLINE&gt;
                hello world
                &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 0, 2, &#39;-&#39;).write(&#34;hello world&#34;)
        hello world

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1, 2, &#39;-&#39;).write(&#34;hello world&#34;)
        --hello world

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2, 2, &#39;-&#39;).write(hello world&#34;)
        ----hello world

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&#34;hello\\nworld\\n&#34;)
            hello
            world
            &lt;BLANKLINE&gt;


        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&#34;hello\\nworld\\n&#34;)
                hello
                world
                &lt;BLANKLINE&gt;

        &gt;&gt;&gt; indenter = TextIOIndenter(sys.stdout, 1)
        ... indenter.write(&#34;hello\\nworld\\n&#34;)
        ... indenter.write(&#34;foo bar\\n&#34;)
            hello
            world
            foo bar

        &gt;&gt;&gt; indenter = TextIOIndenter(sys.stdout, 1)
        ... indenter.write(&#34;hello world &#34;)
        ... indenter.write(&#34;foo bar\\n&#34;)
        ... indenter.write(&#34;this is a test, &#34;)
        ... indenter.write(&#34;more testing\\n&#34;)
        ... indenter.write(&#34;fortytwo\\n&#34;)
            hello world foo bar
            this is a test more testing
            fortytwo

        Returns
        -------
        int
            Number of characters written.

        See Also
        --------
        io.TextIOBase.write
        &#34;&#34;&#34;
        if isinstance(given, bytes):
            indented = given.decode(&#39;utf-8&#39;)
        else:
            indented = given

        # create the indent to insert at begining of given text and every new line in that text
        indent_chars = self.indent_char * (self.indent_size * self.indent_level)

        if self.__unwritten_to:
            self.__unwritten_to = False
            indented = f&#34;{indent_chars}{indented}&#34;

        # add indent after every new line
        # NOTE: \1 is capture group one and contains the original new line character
        indented = re.sub(r&#34;(\r\n|\r|\n)&#34;, r&#34;\1&#34; + indent_chars, indented)

        return self.parent_stream.write(indented)

    def flush(self):
        &#34;&#34;&#34;Flush the parent stream.

        See Also
        --------
        io.TextIOBase.flush
        &#34;&#34;&#34;
        self.parent_stream.flush()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tssc.utils.io.create_sh_redirect_to_multiple_streams_fn_callback"><code class="name flex">
<span>def <span class="ident">create_sh_redirect_to_multiple_streams_fn_callback</span></span>(<span>streams)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns a function callback that will write given data to multiple given streams.</p>
<p>AKA: this essentially allows you to do 'tee' for sh commands.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>streams</code></strong> :&ensp;<code>list</code> of <code>io.IOBase</code></dt>
<dd>Streams to write to.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Will write output directed at stdout to stdout and a results file and output directed
at stderr to stderr and a results file.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; with open('/tmp/results_file', 'w') as results_file:
...     out_callback = create_sh_redirect_to_multiple_streams_fn_callback([
...         sys.stdout,
...         results_file
...     ])
...     err_callback = create_sh_redirect_to_multiple_streams_fn_callback([
...         sys.stderr,
...         results_file
...     ])
...     sh.echo('hello world')
hello world
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function(data)</code></dt>
<dd>Function that takes one parameter, data, and writes that value to all the given streams.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_sh_redirect_to_multiple_streams_fn_callback(streams):
    &#34;&#34;&#34;Creates and returns a function callback that will write given data to multiple given streams.

    AKA: this essentially allows you to do &#39;tee&#39; for sh commands.

    Parameters
    ----------
    streams : list of io.IOBase
        Streams to write to.

    Examples
    --------
    Will write output directed at stdout to stdout and a results file and output directed
    at stderr to stderr and a results file.
    &gt;&gt;&gt; with open(&#39;/tmp/results_file&#39;, &#39;w&#39;) as results_file:
    ...     out_callback = create_sh_redirect_to_multiple_streams_fn_callback([
    ...         sys.stdout,
    ...         results_file
    ...     ])
    ...     err_callback = create_sh_redirect_to_multiple_streams_fn_callback([
    ...         sys.stderr,
    ...         results_file
    ...     ])
    ...     sh.echo(&#39;hello world&#39;)
    hello world

    Returns
    -------
    function(data)
        Function that takes one parameter, data, and writes that value to all the given streams.
    &#34;&#34;&#34;
    def sh_redirect_to_multiple_streams(data):
        for stream in streams:
            stream.write(data)

    return sh_redirect_to_multiple_streams</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tssc.utils.io.TextIOIndenter"><code class="flex name class">
<span>class <span class="ident">TextIOIndenter</span></span>
<span>(</span><span>parent_stream, indent_level=0, indent_size=4, indent_char=' ')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an indent to the first string written and after every new line written to this stream.</p>
<h2 id="notes">Notes</h2>
<p>WARNING:
There will be a dangling indent after the last new line written to this stream
because there is no "good" way of knowing the last new line ever written to this
stream.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent_stream</code></strong> :&ensp;<code>IOBase</code></dt>
<dd>Stream to write to after indenting what is written to this stream</dd>
<dt><strong><code>indent_level</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Level to indent to.
Will be multiplied by the indent_size.</dd>
<dt><strong><code>indent_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Size of each indent.
Will be multipled by the indent_level.</dd>
<dt><strong><code>indent_char</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Character to use for indent.
Will be multiplied by the indent_size and the ident_level and prepended before
each line written to this stream.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextIOIndenter(io.TextIOBase):
    &#34;&#34;&#34;Adds an indent to the first string written and after every new line written to this stream.

    Notes
    -----
    WARNING:    There will be a dangling indent after the last new line written to this stream
                because there is no &#34;good&#34; way of knowing the last new line ever written to this
                stream.

    Parameters
    ----------
    parent_stream : IOBase
        Stream to write to after indenting what is written to this stream
    indent_level : int, optional
        Level to indent to.
        Will be multiplied by the indent_size.
    indent_size : int, optional
        Size of each indent.
        Will be multipled by the indent_level.
    indent_char : str, optional
        Character to use for indent.
        Will be multiplied by the indent_size and the ident_level and prepended before
        each line written to this stream.
    &#34;&#34;&#34;

    def __init__(self, parent_stream, indent_level=0, indent_size=4, indent_char=&#39; &#39;):
        self.__parent_stream = parent_stream
        self.__indent_level = indent_level
        self.__indent_size = indent_size
        self.__indent_char = indent_char
        self.__unwritten_to = True
        super().__init__()

    @property
    def parent_stream(self):
        &#34;&#34;&#34;Returns parent stream that this stream wraps

        Returns
        -------
        IOBase
            Stream to write to after indenting what is written to this stream
        &#34;&#34;&#34;
        return self.__parent_stream

    @property
    def indent_level(self):
        &#34;&#34;&#34;Level to indent to.

        Returns
        -------
        int
            Level to indent to.
        &#34;&#34;&#34;
        return self.__indent_level

    @property
    def indent_size(self):
        &#34;&#34;&#34;Size of each indent.

        Returns
        -------
        int
            Size of each indent.
        &#34;&#34;&#34;
        return self.__indent_size

    @property
    def indent_char(self):
        &#34;&#34;&#34;Character to use for indent.

        Will be multiplied by the indent_size and the ident_level and prepended before
        each line written to this stream.

        Returns
        -------
        str
            Character to use for indent.
        &#34;&#34;&#34;
        return self.__indent_char

    def write(self, given):
        &#34;&#34;&#34;Indents the begining of the given text as well as every new line in the given text
        and then writes it to this steams parent_stream.

        Notes
        -----
        If there is a new line at the end of the given string there will not be an indent
        written after that new line assuming that the next line will be written by this stream
        and therefor get indented as being initially written to this stream.

        Parameters
        ----------
        given : str or bytes (utf-8)
            String to indent every line of before writing to parent stream.

        Examples
        --------
        &gt;&gt;&gt; TextIOIndenter(sys.stdout).write(&#34;hello world\\n&#34;)
        hello world
        &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&#34;hello world\\n&#34;)
            hello world
            &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&#34;hello world\\n&#34;)
                hello world
                &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout).write(&#34;\\nhello world\\n&#34;)
        &lt;BLANKLINE&gt;
        hello world
        &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&#34;\\nhello world\\n&#34;)
            &lt;BLANKLINE&gt;
            hello world
            &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&#34;\\nhello world\\n&#34;)
                &lt;BLANKLINE&gt;
                hello world
                &lt;BLANKLINE&gt;

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 0, 2, &#39;-&#39;).write(&#34;hello world&#34;)
        hello world

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1, 2, &#39;-&#39;).write(&#34;hello world&#34;)
        --hello world

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2, 2, &#39;-&#39;).write(hello world&#34;)
        ----hello world

        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&#34;hello\\nworld\\n&#34;)
            hello
            world
            &lt;BLANKLINE&gt;


        &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&#34;hello\\nworld\\n&#34;)
                hello
                world
                &lt;BLANKLINE&gt;

        &gt;&gt;&gt; indenter = TextIOIndenter(sys.stdout, 1)
        ... indenter.write(&#34;hello\\nworld\\n&#34;)
        ... indenter.write(&#34;foo bar\\n&#34;)
            hello
            world
            foo bar

        &gt;&gt;&gt; indenter = TextIOIndenter(sys.stdout, 1)
        ... indenter.write(&#34;hello world &#34;)
        ... indenter.write(&#34;foo bar\\n&#34;)
        ... indenter.write(&#34;this is a test, &#34;)
        ... indenter.write(&#34;more testing\\n&#34;)
        ... indenter.write(&#34;fortytwo\\n&#34;)
            hello world foo bar
            this is a test more testing
            fortytwo

        Returns
        -------
        int
            Number of characters written.

        See Also
        --------
        io.TextIOBase.write
        &#34;&#34;&#34;
        if isinstance(given, bytes):
            indented = given.decode(&#39;utf-8&#39;)
        else:
            indented = given

        # create the indent to insert at begining of given text and every new line in that text
        indent_chars = self.indent_char * (self.indent_size * self.indent_level)

        if self.__unwritten_to:
            self.__unwritten_to = False
            indented = f&#34;{indent_chars}{indented}&#34;

        # add indent after every new line
        # NOTE: \1 is capture group one and contains the original new line character
        indented = re.sub(r&#34;(\r\n|\r|\n)&#34;, r&#34;\1&#34; + indent_chars, indented)

        return self.parent_stream.write(indented)

    def flush(self):
        &#34;&#34;&#34;Flush the parent stream.

        See Also
        --------
        io.TextIOBase.flush
        &#34;&#34;&#34;
        self.parent_stream.flush()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>io.TextIOBase</li>
<li>_io._TextIOBase</li>
<li>io.IOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tssc.utils.io.TextIOIndenter.indent_char"><code class="name">var <span class="ident">indent_char</span></code></dt>
<dd>
<div class="desc"><p>Character to use for indent.</p>
<p>Will be multiplied by the indent_size and the ident_level and prepended before
each line written to this stream.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Character to use for indent.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def indent_char(self):
    &#34;&#34;&#34;Character to use for indent.

    Will be multiplied by the indent_size and the ident_level and prepended before
    each line written to this stream.

    Returns
    -------
    str
        Character to use for indent.
    &#34;&#34;&#34;
    return self.__indent_char</code></pre>
</details>
</dd>
<dt id="tssc.utils.io.TextIOIndenter.indent_level"><code class="name">var <span class="ident">indent_level</span></code></dt>
<dd>
<div class="desc"><p>Level to indent to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Level to indent to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def indent_level(self):
    &#34;&#34;&#34;Level to indent to.

    Returns
    -------
    int
        Level to indent to.
    &#34;&#34;&#34;
    return self.__indent_level</code></pre>
</details>
</dd>
<dt id="tssc.utils.io.TextIOIndenter.indent_size"><code class="name">var <span class="ident">indent_size</span></code></dt>
<dd>
<div class="desc"><p>Size of each indent.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Size of each indent.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def indent_size(self):
    &#34;&#34;&#34;Size of each indent.

    Returns
    -------
    int
        Size of each indent.
    &#34;&#34;&#34;
    return self.__indent_size</code></pre>
</details>
</dd>
<dt id="tssc.utils.io.TextIOIndenter.parent_stream"><code class="name">var <span class="ident">parent_stream</span></code></dt>
<dd>
<div class="desc"><p>Returns parent stream that this stream wraps</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>IOBase</code></dt>
<dd>Stream to write to after indenting what is written to this stream</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent_stream(self):
    &#34;&#34;&#34;Returns parent stream that this stream wraps

    Returns
    -------
    IOBase
        Stream to write to after indenting what is written to this stream
    &#34;&#34;&#34;
    return self.__parent_stream</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tssc.utils.io.TextIOIndenter.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flush the parent stream.</p>
<h2 id="see-also">See Also</h2>
<p><code>io.TextIOBase.flush</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self):
    &#34;&#34;&#34;Flush the parent stream.

    See Also
    --------
    io.TextIOBase.flush
    &#34;&#34;&#34;
    self.parent_stream.flush()</code></pre>
</details>
</dd>
<dt id="tssc.utils.io.TextIOIndenter.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, given)</span>
</code></dt>
<dd>
<div class="desc"><p>Indents the begining of the given text as well as every new line in the given text
and then writes it to this steams parent_stream.</p>
<h2 id="notes">Notes</h2>
<p>If there is a new line at the end of the given string there will not be an indent
written after that new line assuming that the next line will be written by this stream
and therefor get indented as being initially written to this stream.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>given</code></strong> :&ensp;<code>str</code> or <code>bytes (utf-8)</code></dt>
<dd>String to indent every line of before writing to parent stream.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout).write(&quot;hello world\n&quot;)
hello world
&lt;BLANKLINE&gt;
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&quot;hello world\n&quot;)
    hello world
    &lt;BLANKLINE&gt;
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&quot;hello world\n&quot;)
        hello world
        &lt;BLANKLINE&gt;
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout).write(&quot;\nhello world\n&quot;)
&lt;BLANKLINE&gt;
hello world
&lt;BLANKLINE&gt;
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&quot;\nhello world\n&quot;)
    &lt;BLANKLINE&gt;
    hello world
    &lt;BLANKLINE&gt;
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&quot;\nhello world\n&quot;)
        &lt;BLANKLINE&gt;
        hello world
        &lt;BLANKLINE&gt;
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout, 0, 2, '-').write(&quot;hello world&quot;)
hello world
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout, 1, 2, '-').write(&quot;hello world&quot;)
--hello world
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout, 2, 2, '-').write(hello world&quot;)
----hello world
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&quot;hello\nworld\n&quot;)
    hello
    world
    &lt;BLANKLINE&gt;
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&quot;hello\nworld\n&quot;)
        hello
        world
        &lt;BLANKLINE&gt;
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; indenter = TextIOIndenter(sys.stdout, 1)
... indenter.write(&quot;hello\nworld\n&quot;)
... indenter.write(&quot;foo bar\n&quot;)
    hello
    world
    foo bar
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; indenter = TextIOIndenter(sys.stdout, 1)
... indenter.write(&quot;hello world &quot;)
... indenter.write(&quot;foo bar\n&quot;)
... indenter.write(&quot;this is a test, &quot;)
... indenter.write(&quot;more testing\n&quot;)
... indenter.write(&quot;fortytwo\n&quot;)
    hello world foo bar
    this is a test more testing
    fortytwo
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of characters written.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>io.TextIOBase.write</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, given):
    &#34;&#34;&#34;Indents the begining of the given text as well as every new line in the given text
    and then writes it to this steams parent_stream.

    Notes
    -----
    If there is a new line at the end of the given string there will not be an indent
    written after that new line assuming that the next line will be written by this stream
    and therefor get indented as being initially written to this stream.

    Parameters
    ----------
    given : str or bytes (utf-8)
        String to indent every line of before writing to parent stream.

    Examples
    --------
    &gt;&gt;&gt; TextIOIndenter(sys.stdout).write(&#34;hello world\\n&#34;)
    hello world
    &lt;BLANKLINE&gt;

    &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&#34;hello world\\n&#34;)
        hello world
        &lt;BLANKLINE&gt;

    &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&#34;hello world\\n&#34;)
            hello world
            &lt;BLANKLINE&gt;

    &gt;&gt;&gt; TextIOIndenter(sys.stdout).write(&#34;\\nhello world\\n&#34;)
    &lt;BLANKLINE&gt;
    hello world
    &lt;BLANKLINE&gt;

    &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&#34;\\nhello world\\n&#34;)
        &lt;BLANKLINE&gt;
        hello world
        &lt;BLANKLINE&gt;

    &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&#34;\\nhello world\\n&#34;)
            &lt;BLANKLINE&gt;
            hello world
            &lt;BLANKLINE&gt;

    &gt;&gt;&gt; TextIOIndenter(sys.stdout, 0, 2, &#39;-&#39;).write(&#34;hello world&#34;)
    hello world

    &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1, 2, &#39;-&#39;).write(&#34;hello world&#34;)
    --hello world

    &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2, 2, &#39;-&#39;).write(hello world&#34;)
    ----hello world

    &gt;&gt;&gt; TextIOIndenter(sys.stdout, 1).write(&#34;hello\\nworld\\n&#34;)
        hello
        world
        &lt;BLANKLINE&gt;


    &gt;&gt;&gt; TextIOIndenter(sys.stdout, 2).write(&#34;hello\\nworld\\n&#34;)
            hello
            world
            &lt;BLANKLINE&gt;

    &gt;&gt;&gt; indenter = TextIOIndenter(sys.stdout, 1)
    ... indenter.write(&#34;hello\\nworld\\n&#34;)
    ... indenter.write(&#34;foo bar\\n&#34;)
        hello
        world
        foo bar

    &gt;&gt;&gt; indenter = TextIOIndenter(sys.stdout, 1)
    ... indenter.write(&#34;hello world &#34;)
    ... indenter.write(&#34;foo bar\\n&#34;)
    ... indenter.write(&#34;this is a test, &#34;)
    ... indenter.write(&#34;more testing\\n&#34;)
    ... indenter.write(&#34;fortytwo\\n&#34;)
        hello world foo bar
        this is a test more testing
        fortytwo

    Returns
    -------
    int
        Number of characters written.

    See Also
    --------
    io.TextIOBase.write
    &#34;&#34;&#34;
    if isinstance(given, bytes):
        indented = given.decode(&#39;utf-8&#39;)
    else:
        indented = given

    # create the indent to insert at begining of given text and every new line in that text
    indent_chars = self.indent_char * (self.indent_size * self.indent_level)

    if self.__unwritten_to:
        self.__unwritten_to = False
        indented = f&#34;{indent_chars}{indented}&#34;

    # add indent after every new line
    # NOTE: \1 is capture group one and contains the original new line character
    indented = re.sub(r&#34;(\r\n|\r|\n)&#34;, r&#34;\1&#34; + indent_chars, indented)

    return self.parent_stream.write(indented)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tssc.utils.io.TextIOSelectiveObfuscator"><code class="flex name class">
<span>class <span class="ident">TextIOSelectiveObfuscator</span></span>
<span>(</span><span>parent_stream, randomize_replacment_length=True, replacement_char='*')</span>
</code></dt>
<dd>
<div class="desc"><p>Extends the base class for text streams to allow the obfuscation of given patterns.</p>
<p>This is useful to prevent accidentally writing "sensitive" information to stdout/stderr.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent_stream</code></strong> :&ensp;<code>IOBase</code></dt>
<dd>IO stream to write to after obfuscating any text written to this stream.</dd>
<dt><strong><code>randomize_replacment_length</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to randomize the length of the text being obfuscated in the stream.
False to use the same length replacement for any obfuscated text in the stream.</dd>
<dt><strong><code>replacement_char</code></strong> :&ensp;<code>char</code></dt>
<dd>Character to replace the target strings to obfuscate with.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__parent_stream</code></strong> :&ensp;<code>IOBase</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>__obfuscation_paterns</code></strong> :&ensp;<code>list</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>__replacement_char</code></strong> :&ensp;<code>char</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>__randomize_replacment_length</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>__random_replacement_length_min</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>__random_replacment_length_max</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextIOSelectiveObfuscator(io.TextIOBase):
    &#34;&#34;&#34;Extends the base class for text streams to allow the obfuscation of given patterns.

    This is useful to prevent accidentally writing &#34;sensitive&#34; information to stdout/stderr.

    Parameters
    ----------
    parent_stream : IOBase
        IO stream to write to after obfuscating any text written to this stream.
    randomize_replacment_length : bool, optional
        True to randomize the length of the text being obfuscated in the stream.
        False to use the same length replacement for any obfuscated text in the stream.
    replacement_char : char
        Character to replace the target strings to obfuscate with.

    Attributes
    ----------
    __parent_stream : IOBase
    __obfuscation_paterns : list
    __replacement_char : char
    __randomize_replacment_length : bool
    __random_replacement_length_min : int
    __random_replacment_length_max : int
    &#34;&#34;&#34;

    def __init__(self, parent_stream, randomize_replacment_length=True, replacement_char=&#39;*&#39;):
        self.__parent_stream = parent_stream
        self.__obfuscation_paterns = []
        self.__replacement_char = replacement_char
        self.__randomize_replacment_length = randomize_replacment_length
        self.__random_replacement_length_min = 5
        self.__random_replacment_length_max = 40
        super().__init__()

    @property
    def parent_stream(self):
        &#34;&#34;&#34;
        Returns
        -------
        IOBase
            IO stream this stream writes to after obfuscating any text written to this stream.
        &#34;&#34;&#34;
        return self.__parent_stream

    @property
    def replacement_char(self):
        &#34;&#34;&#34;
        Returns
        -------
        char
            Character to replace the target strings to obfuscate with.
        &#34;&#34;&#34;
        return self.__replacement_char

    @replacement_char.setter
    def replacement_char(self, replacement_char):
        &#34;&#34;&#34;
        Parameters
        ----------
        replacement_char : char
            Character to replace the target strings to obfuscate with.
        &#34;&#34;&#34;
        self.__replacement_char = replacement_char

    @property
    def randomize_replacment_length(self):
        &#34;&#34;&#34;
        Returns
        -------
        bool
            True if this stream is randomizing the length of the text being obfuscated.
            False if this stream is using the same length replacement for any obfuscated text.
        &#34;&#34;&#34;
        return self.__randomize_replacment_length

    def add_obfuscation_targets(self, targets):
        &#34;&#34;&#34;Adds a target pattern to be obfuscated whenever writing to this stream.

        Notes
        -----
        This is a bit involved to deal with secrets that span multiple lines and various ways they
        can be printed. so the regex gets pretty involved to escape the right things and ignore
        whitespace, so forth and so on.

        There are unit tests covering the scenarios this is dealing with, if you are messing in
        here be sure you don&#39;t break any of the existing unit tests.

        Parameters
        ----------
        targets : list or pattern
            The target patterns to be obfuscated when writing to this stream.
        &#34;&#34;&#34;
        if not isinstance(targets, list):
            targets = [targets]

        for target in targets:
            target_pattern = target

            # replace any amount of whitespace with a single space
            target_pattern = re.sub(r&#39;\s+&#39;, &#39; &#39;, target_pattern)

            # strip off leading and trialing whitespace
            target_pattern = target_pattern.strip()

            # escape for use in regex pattern
            target_pattern = re.escape(target_pattern)

            # the spaces we added in now got escaped, so unescape them and turn them into .*
            target_pattern = re.sub(r&#39;\\ &#39;, r&#39;.*&#39;, target_pattern)

            # eat up pre and post newlines
            #target_pattern = f&#34;(\s*)({target_pattern})(\s*)&#34;

            # compile the pattern for re-use and make sure that .* matches accross lines
            target_compiled_pattern = re.compile(target_pattern, re.DOTALL)

            # add the pattern
            self.__obfuscation_paterns.append(target_compiled_pattern)

    def __obfuscator(self, match):
        &#34;&#34;&#34;Given a regex match returns a corresponding obfuscated string.

        Parameters
        ----------
        match : re.Match
            re.Match to replace with obfuscated text

        Returns
        -------
        str
            String to replace the given match with.

        Also See
        --------
        re.sub
        &#34;&#34;&#34;

        if self.randomize_replacment_length:
            replacment_length = random.randint(
                self.__random_replacement_length_min,
                self.__random_replacment_length_max
            )
        else:
            replacment_length = len(match.group())

        return self.replacement_char * replacment_length

    def write(self, given):
        &#34;&#34;&#34;Writes to this streams parent stream after obfuscating all of the obfuscation targets.

        Parameters
        ----------
        given : str
            Given string to write to the parent stream after obfuscating.

        Returns
        -------
        int
            Number of characters written.

        See Also
        --------
        io.TextIOBase.write
        &#34;&#34;&#34;

        if isinstance(given, bytes):
            obfuscated = given.decode(&#39;utf-8&#39;)
        else:
            obfuscated = given

        for obfuscation_pattern in self.__obfuscation_paterns:
            obfuscated = obfuscation_pattern.sub(self.__obfuscator, obfuscated)

        return self.parent_stream.write(obfuscated)

    def flush(self):
        &#34;&#34;&#34;Flush the parent stream.

        See Also
        --------
        io.TextIOBase.flush
        &#34;&#34;&#34;
        self.parent_stream.flush()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>io.TextIOBase</li>
<li>_io._TextIOBase</li>
<li>io.IOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tssc.utils.io.TextIOSelectiveObfuscator.parent_stream"><code class="name">var <span class="ident">parent_stream</span></code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>IOBase</code></dt>
<dd>IO stream this stream writes to after obfuscating any text written to this stream.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent_stream(self):
    &#34;&#34;&#34;
    Returns
    -------
    IOBase
        IO stream this stream writes to after obfuscating any text written to this stream.
    &#34;&#34;&#34;
    return self.__parent_stream</code></pre>
</details>
</dd>
<dt id="tssc.utils.io.TextIOSelectiveObfuscator.randomize_replacment_length"><code class="name">var <span class="ident">randomize_replacment_length</span></code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if this stream is randomizing the length of the text being obfuscated.
False if this stream is using the same length replacement for any obfuscated text.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def randomize_replacment_length(self):
    &#34;&#34;&#34;
    Returns
    -------
    bool
        True if this stream is randomizing the length of the text being obfuscated.
        False if this stream is using the same length replacement for any obfuscated text.
    &#34;&#34;&#34;
    return self.__randomize_replacment_length</code></pre>
</details>
</dd>
<dt id="tssc.utils.io.TextIOSelectiveObfuscator.replacement_char"><code class="name">var <span class="ident">replacement_char</span></code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>char</code></dt>
<dd>Character to replace the target strings to obfuscate with.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def replacement_char(self):
    &#34;&#34;&#34;
    Returns
    -------
    char
        Character to replace the target strings to obfuscate with.
    &#34;&#34;&#34;
    return self.__replacement_char</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tssc.utils.io.TextIOSelectiveObfuscator.add_obfuscation_targets"><code class="name flex">
<span>def <span class="ident">add_obfuscation_targets</span></span>(<span>self, targets)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a target pattern to be obfuscated whenever writing to this stream.</p>
<h2 id="notes">Notes</h2>
<p>This is a bit involved to deal with secrets that span multiple lines and various ways they
can be printed. so the regex gets pretty involved to escape the right things and ignore
whitespace, so forth and so on.</p>
<p>There are unit tests covering the scenarios this is dealing with, if you are messing in
here be sure you don't break any of the existing unit tests.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>targets</code></strong> :&ensp;<code>list</code> or <code>pattern</code></dt>
<dd>The target patterns to be obfuscated when writing to this stream.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_obfuscation_targets(self, targets):
    &#34;&#34;&#34;Adds a target pattern to be obfuscated whenever writing to this stream.

    Notes
    -----
    This is a bit involved to deal with secrets that span multiple lines and various ways they
    can be printed. so the regex gets pretty involved to escape the right things and ignore
    whitespace, so forth and so on.

    There are unit tests covering the scenarios this is dealing with, if you are messing in
    here be sure you don&#39;t break any of the existing unit tests.

    Parameters
    ----------
    targets : list or pattern
        The target patterns to be obfuscated when writing to this stream.
    &#34;&#34;&#34;
    if not isinstance(targets, list):
        targets = [targets]

    for target in targets:
        target_pattern = target

        # replace any amount of whitespace with a single space
        target_pattern = re.sub(r&#39;\s+&#39;, &#39; &#39;, target_pattern)

        # strip off leading and trialing whitespace
        target_pattern = target_pattern.strip()

        # escape for use in regex pattern
        target_pattern = re.escape(target_pattern)

        # the spaces we added in now got escaped, so unescape them and turn them into .*
        target_pattern = re.sub(r&#39;\\ &#39;, r&#39;.*&#39;, target_pattern)

        # eat up pre and post newlines
        #target_pattern = f&#34;(\s*)({target_pattern})(\s*)&#34;

        # compile the pattern for re-use and make sure that .* matches accross lines
        target_compiled_pattern = re.compile(target_pattern, re.DOTALL)

        # add the pattern
        self.__obfuscation_paterns.append(target_compiled_pattern)</code></pre>
</details>
</dd>
<dt id="tssc.utils.io.TextIOSelectiveObfuscator.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flush the parent stream.</p>
<h2 id="see-also">See Also</h2>
<p><code>io.TextIOBase.flush</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self):
    &#34;&#34;&#34;Flush the parent stream.

    See Also
    --------
    io.TextIOBase.flush
    &#34;&#34;&#34;
    self.parent_stream.flush()</code></pre>
</details>
</dd>
<dt id="tssc.utils.io.TextIOSelectiveObfuscator.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, given)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes to this streams parent stream after obfuscating all of the obfuscation targets.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>given</code></strong> :&ensp;<code>str</code></dt>
<dd>Given string to write to the parent stream after obfuscating.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of characters written.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>io.TextIOBase.write</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, given):
    &#34;&#34;&#34;Writes to this streams parent stream after obfuscating all of the obfuscation targets.

    Parameters
    ----------
    given : str
        Given string to write to the parent stream after obfuscating.

    Returns
    -------
    int
        Number of characters written.

    See Also
    --------
    io.TextIOBase.write
    &#34;&#34;&#34;

    if isinstance(given, bytes):
        obfuscated = given.decode(&#39;utf-8&#39;)
    else:
        obfuscated = given

    for obfuscation_pattern in self.__obfuscation_paterns:
        obfuscated = obfuscation_pattern.sub(self.__obfuscator, obfuscated)

    return self.parent_stream.write(obfuscated)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tssc.utils" href="index.html">tssc.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tssc.utils.io.create_sh_redirect_to_multiple_streams_fn_callback" href="#tssc.utils.io.create_sh_redirect_to_multiple_streams_fn_callback">create_sh_redirect_to_multiple_streams_fn_callback</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tssc.utils.io.TextIOIndenter" href="#tssc.utils.io.TextIOIndenter">TextIOIndenter</a></code></h4>
<ul class="two-column">
<li><code><a title="tssc.utils.io.TextIOIndenter.flush" href="#tssc.utils.io.TextIOIndenter.flush">flush</a></code></li>
<li><code><a title="tssc.utils.io.TextIOIndenter.indent_char" href="#tssc.utils.io.TextIOIndenter.indent_char">indent_char</a></code></li>
<li><code><a title="tssc.utils.io.TextIOIndenter.indent_level" href="#tssc.utils.io.TextIOIndenter.indent_level">indent_level</a></code></li>
<li><code><a title="tssc.utils.io.TextIOIndenter.indent_size" href="#tssc.utils.io.TextIOIndenter.indent_size">indent_size</a></code></li>
<li><code><a title="tssc.utils.io.TextIOIndenter.parent_stream" href="#tssc.utils.io.TextIOIndenter.parent_stream">parent_stream</a></code></li>
<li><code><a title="tssc.utils.io.TextIOIndenter.write" href="#tssc.utils.io.TextIOIndenter.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tssc.utils.io.TextIOSelectiveObfuscator" href="#tssc.utils.io.TextIOSelectiveObfuscator">TextIOSelectiveObfuscator</a></code></h4>
<ul class="">
<li><code><a title="tssc.utils.io.TextIOSelectiveObfuscator.add_obfuscation_targets" href="#tssc.utils.io.TextIOSelectiveObfuscator.add_obfuscation_targets">add_obfuscation_targets</a></code></li>
<li><code><a title="tssc.utils.io.TextIOSelectiveObfuscator.flush" href="#tssc.utils.io.TextIOSelectiveObfuscator.flush">flush</a></code></li>
<li><code><a title="tssc.utils.io.TextIOSelectiveObfuscator.parent_stream" href="#tssc.utils.io.TextIOSelectiveObfuscator.parent_stream">parent_stream</a></code></li>
<li><code><a title="tssc.utils.io.TextIOSelectiveObfuscator.randomize_replacment_length" href="#tssc.utils.io.TextIOSelectiveObfuscator.randomize_replacment_length">randomize_replacment_length</a></code></li>
<li><code><a title="tssc.utils.io.TextIOSelectiveObfuscator.replacement_char" href="#tssc.utils.io.TextIOSelectiveObfuscator.replacement_char">replacement_char</a></code></li>
<li><code><a title="tssc.utils.io.TextIOSelectiveObfuscator.write" href="#tssc.utils.io.TextIOSelectiveObfuscator.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>