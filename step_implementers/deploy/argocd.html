<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ploigos_step_runner.step_implementers.deploy.argocd API documentation</title>
<meta name="description" content="`StepImplementer` for the `deploy` step using ArgoCD â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ploigos_step_runner.step_implementers.deploy.argocd</code></h1>
</header>
<section id="section-intro">
<p><code>StepImplementer</code> for the <code>deploy</code> step using ArgoCD.</p>
<h2 id="step-configuration">Step Configuration</h2>
<p>Step configuration expected as input to this step.
Could come from:</p>
<ul>
<li>static configuration</li>
<li>runtime configuration</li>
<li>previous step results</li>
</ul>
<table>
<thead>
<tr>
<th>Configuration Key</th>
<th>Required?</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>argocd-username</code></td>
<td>Yes</td>
<td></td>
<td>Username for accessing the ArgoCD API</td>
</tr>
<tr>
<td><code>argocd-password</code></td>
<td>Yes</td>
<td></td>
<td>Password for accessing the ArgoCD API</td>
</tr>
<tr>
<td><code>argocd-api</code></td>
<td>Yes</td>
<td></td>
<td>The ArgoCD API endpoint</td>
</tr>
<tr>
<td><code>argocd-auto-sync</code></td>
<td>Yes</td>
<td>True</td>
<td>If set to false, argo cd will sync only if
explicitly told to do so via the UI or CLI.
Otherwise it will sync if the repo contents
have changed</td>
</tr>
<tr>
<td><code>argocd-skip-tls</code></td>
<td>Yes</td>
<td>False</td>
<td><code>False</code> to not ignore TLS issues when
authenticating with ArgoCD. True` to ignore TLS
issues when authenticating with ArgoCD.</td>
</tr>
<tr>
<td><code>argocd-sync-timeout-seconds</code></td>
<td>Yes</td>
<td>60</td>
<td>Number of seconds to wait for argocd to
sync updates</td>
</tr>
<tr>
<td><code>argocd-sync-retry-limit</code></td>
<td>No</td>
<td>3</td>
<td>Value to pass to retry limit flag for argo sync</td>
</tr>
<tr>
<td><code>argocd-sync-prune</code></td>
<td>No</td>
<td>True</td>
<td></td>
</tr>
<tr>
<td><code>deployment-config-repo</code></td>
<td>Yes</td>
<td></td>
<td>The repo containing the helm chart definition</td>
</tr>
<tr>
<td><code>deployment-config-helm-chart-path</code></td>
<td>Yes</td>
<td>./</td>
<td>Directory containing the helm chart definition</td>
</tr>
<tr>
<td><code>deployment-config-helm-chart-environment-values-file</code></td>
<td>No</td>
<td>values-{ENV}.yaml</td>
<td>File to update with environment
deployment specific information.
<br/>
Default value uses <code>environment</code>
configuration option to calculate file
name.</td>
</tr>
<tr>
<td><code>deployment-config-helm-chart-additional-values-files</code></td>
<td>No</td>
<td></td>
<td>Array of additional values files.
Paths must be relative to the given
Helm Chart path (<code>deployment-config-helm-chart-path</code>).
<br/>
Does not need to include
<code>deployment-config-helm-chart-environment-values-file</code>
as it will be automatically included as the
last <code>--values</code> flag.</td>
</tr>
<tr>
<td><br/>
Used when createing the ArgoCD Application.
<br/><br/>
<strong>NOTE:</strong> Helm will always pick up <code>values.yaml</code>
by default whether or not additional values
files are provided, therefor no need to
explicitly provide.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>deployment-config-helm-chart-values-file-image-tag-yq-path</code></td>
<td>Yes</td>
<td><code>image_tag</code></td>
<td>YQ path to value in <code>deployment-config-helm-chart-environment-values-file</code>
to update with the <code>container-image-tag</code>
before deployment.
<br/>
<strong>SEE:</strong>: <a href="https://github.com/mikefarah/yq">https://github.com/mikefarah/yq</a>
for documentation on valid yq paths.</td>
</tr>
<tr>
<td><code>kube-api-uri</code></td>
<td>Yes</td>
<td><a href="https://kubernetes.default.svc">https://kubernetes.default.svc</a></td>
<td>k8s API endpoint</td>
</tr>
<tr>
<td><code>kube-api-token</code></td>
<td>No</td>
<td></td>
<td>k8s API token. This is used to add an external
k8s cluster into argocd. It is required if the
cluster has not already been added to ArgoCD.
The token should be persistent
(.e.g, a service account token) and have cluster
admin access.</td>
</tr>
<tr>
<td><code>kube-api-skip-tls</code></td>
<td>Yes</td>
<td>False</td>
<td>Whether or not to skip tls verification when
authenticating to an external k8s cluster.
Used when a new cluster is registered with
argocd.</td>
</tr>
<tr>
<td><code>git-email</code></td>
<td>Yes</td>
<td></td>
<td>Git email for commit</td>
</tr>
<tr>
<td><code>git-name</code></td>
<td>Yes</td>
<td><code>Ploigos Robot</code></td>
<td>Git name for commit</td>
</tr>
<tr>
<td><code>git-username</code></td>
<td>No</td>
<td></td>
<td>If the helm config repo s accessed via http(s)
this must be supplied</td>
</tr>
<tr>
<td><code>git-password</code></td>
<td>No</td>
<td></td>
<td>If the helm config repo is accessed via http(s)
this must be supplied</td>
</tr>
<tr>
<td><code>tag</code></td>
<td>No</td>
<td>latest</td>
<td>The git tag to apply to the config repo.
If not supplied <code>version</code> will be used.
If <code>version</code> not supplied <code>latest</code> will be used.</td>
</tr>
<tr>
<td><code>version</code></td>
<td>No</td>
<td>latest</td>
<td>Ignored if <code>tag</code> is provided.
The git tag to apply to the config repo if <code>tag</code>
is not supplied.
If <code>tag</code> and <code>version</code> not supplied <code>latest</code>
will be used.</td>
</tr>
<tr>
<td><code>container-image-tag</code></td>
<td>Yes</td>
<td></td>
<td>Tag container image was pushed with. <br/>
Takes the form of:
"<code>container-image-registry-uri</code>
/<code>container-image-registry-organization</code>
/<code>container-image-repository</code>
:<code>container-image-version</code>"</td>
</tr>
<tr>
<td><code>force-push-tags</code></td>
<td>No</td>
<td>False</td>
<td>Force push Git Tags</td>
</tr>
<tr>
<td><code>additional-helm-values-files</code></td>
<td>No</td>
<td>[]</td>
<td>Array of value files to add to argocd app for helm use</td>
</tr>
</tbody>
</table>
<h2 id="results">Results</h2>
<p>Results output by this step.</p>
<table>
<thead>
<tr>
<th>Result Key</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>argocd-app-name</code></td>
<td>The argocd app name that was created or updated</td>
</tr>
<tr>
<td><code>deployed-host-urls</code></td>
<td>The host URLs deployed by ArgoCD (Ingress/Route resources)</td>
</tr>
<tr>
<td><code>config-repo-git-tag</code></td>
<td>The git tag applied to the configuration repo for deployment</td>
</tr>
<tr>
<td><code>argocd-deployed-manifest</code></td>
<td>The generated yml file used for deployment.</td>
</tr>
</tbody>
</table>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># pylint: disable=too-many-lines
&#34;&#34;&#34;`StepImplementer` for the `deploy` step using ArgoCD.

Step Configuration
------------------
Step configuration expected as input to this step.
Could come from:

  * static configuration
  * runtime configuration
  * previous step results

Configuration Key         | Required? | Default  | Description
--------------------------|-----------|----------|---------------------------
`argocd-username`         | Yes       |          | Username for accessing the ArgoCD API
`argocd-password`         | Yes       |          | Password for accessing the ArgoCD API
`argocd-api`              | Yes       |          | The ArgoCD API endpoint
`argocd-auto-sync`        | Yes       | True     | If set to false, argo cd will sync only if \
                                                   explicitly told to do so via the UI or CLI. \
                                                   Otherwise it will sync if the repo contents \
                                                   have changed
`argocd-skip-tls`         | Yes       | False    | `False` to not ignore TLS issues when \
                                                   authenticating with ArgoCD. True` to ignore TLS \
                                                   issues when authenticating with ArgoCD.
`argocd-sync-timeout-seconds` \
                          | Yes       | 60       | Number of seconds to wait for argocd to \
                                                   sync updates
`argocd-sync-retry-limit` | No        | 3        | Value to pass to retry limit flag for argo sync
`argocd-sync-prune`       | No        | True     |
`deployment-config-repo`  | Yes       |          | The repo containing the helm chart definition
`deployment-config-helm-chart-path` \
                          | Yes       | ./       | Directory containing the helm chart definition
`deployment-config-helm-chart-environment-values-file` \
                          | No        | values-{ENV}.yaml | File to update with environment \
                                                            deployment specific information. \
                                                            &lt;br/&gt;\
                                                            Default value uses `environment` \
                                                            configuration option to calculate file \
                                                            name.
`deployment-config-helm-chart-additional-values-files` \
                          | No        |          | Array of additional values files. \
                                                   Paths must be relative to the given \
                                                   Helm Chart path (`deployment-config-helm-chart-path`). \
                                                   &lt;br/&gt;\
                                                   Does not need to include \
                                                   `deployment-config-helm-chart-environment-values-file` \
                                                   as it will be automatically included as the \
                                                   last `--values` flag.
                                                   &lt;br/&gt;\
                                                   Used when createing the ArgoCD Application.\
                                                   &lt;br/&gt;&lt;br/&gt;\
                                                   **NOTE:** Helm will always pick up `values.yaml`\
                                                   by default whether or not additional values \
                                                   files are provided, therefor no need to \
                                                   explicitly provide.
`deployment-config-helm-chart-values-file-image-tag-yq-path` \
                          | Yes       | `image_tag` | YQ path to value in `deployment-config-helm-chart-environment-values-file` \
                                                      to update with the `container-image-tag` \
                                                      before deployment. \
                                                      &lt;br/&gt;\
                                                      **SEE:**: https://github.com/mikefarah/yq \
                                                      for documentation on valid yq paths.
`kube-api-uri`            | Yes       | https://kubernetes.default.svc | k8s API endpoint
`kube-api-token`          | No        |          | k8s API token. This is used to add an external \
                                                   k8s cluster into argocd. It is required if the \
                                                   cluster has not already been added to ArgoCD. \
                                                   The token should be persistent \
                                                   (.e.g, a service account token) and have cluster \
                                                   admin access.
`kube-api-skip-tls`       | Yes       | False    | Whether or not to skip tls verification when \
                                                   authenticating to an external k8s cluster. \
                                                   Used when a new cluster is registered with \
                                                   argocd.
`git-email`               | Yes       |          | Git email for commit
`git-name`                | Yes       | `Ploigos Robot` | Git name for commit
`git-username`            | No        |          | If the helm config repo s accessed via http(s) \
                                                   this must be supplied
`git-password`            | No        |          | If the helm config repo is accessed via http(s) \
                                                   this must be supplied
`tag`                     | No        | latest   | The git tag to apply to the config repo. \
                                                   If not supplied `version` will be used. \
                                                   If `version` not supplied `latest` will be used.
`version`                 | No        | latest   | Ignored if `tag` is provided. \
                                                   The git tag to apply to the config repo if `tag` \
                                                   is not supplied. \
                                                   If `tag` and `version` not supplied `latest` \
                                                   will be used.
`container-image-tag`     | Yes       |          | Tag container image was pushed with. &lt;br/&gt;\
                                                   Takes the form of: \
                                                     &#34;`container-image-registry-uri`\
                                                        /`container-image-registry-organization`\
                                                        /`container-image-repository`\
                                                        :`container-image-version`&#34;
`force-push-tags`         | No        | False    | Force push Git Tags
`additional-helm-values-files` | No   | []       | Array of value files to add to argocd app for helm use

Results
-------
Results output by this step.

Result Key                 | Description
---------------------------|------------
`argocd-app-name`          | The argocd app name that was created or updated
`deployed-host-urls`       | The host URLs deployed by ArgoCD (Ingress/Route resources)
`config-repo-git-tag`      | The git tag applied to the configuration repo for deployment
`argocd-deployed-manifest` | The generated yml file used for deployment.
&#34;&#34;&#34; # pylint: disable=line-too-long
import os
import re
import sys

import sh
import yaml
from ploigos_step_runner import StepImplementer
from ploigos_step_runner.exceptions import StepRunnerException
from ploigos_step_runner import StepResult

DEFAULT_CONFIG = {
    &#39;argocd-sync-timeout-seconds&#39;: 60,
    &#39;argocd-sync-retry-limit&#39;: 3,
    &#39;argocd-auto-sync&#39;: True,
    &#39;argocd-skip-tls&#39; : False,
    &#39;argocd-sync-prune&#39;: True,
    &#39;deployment-config-helm-chart-path&#39;: &#39;./&#39;,
    &#39;deployment-config-helm-chart-additional-values-files&#39;: [],
    &#39;additional-helm-values-files&#39;: [],
    &#39;deployment-config-helm-chart-values-file-image-tag-yq-path&#39;: &#39;image_tag&#39;,
    &#39;force-push-tags&#39;: False,
    &#39;kube-api-skip-tls&#39;: False,
    &#39;kube-api-uri&#39;: &#39;https://kubernetes.default.svc&#39;,
    &#39;git-name&#39;: &#39;Ploigos Robot&#39;
}

REQUIRED_CONFIG_OR_PREVIOUS_STEP_RESULT_ARTIFACT_KEYS = [
    &#39;argocd-username&#39;,
    &#39;argocd-password&#39;,
    &#39;argocd-api&#39;,
    &#39;argocd-skip-tls&#39;,
    &#39;deployment-config-repo&#39;,
    &#39;deployment-config-helm-chart-path&#39;,
    &#39;deployment-config-helm-chart-values-file-image-tag-yq-path&#39;,
    &#39;git-email&#39;,
    &#39;git-name&#39;,
    &#39;container-image-tag&#39;
]

GIT_AUTHENTICATION_CONFIG = {
    &#39;git-username&#39;: None,
    &#39;git-password&#39;: None
}

KUBE_LABEL_NOT_SAFE_CHARS_REGEX = r&#34;[^a-zA-Z0-9\-_\.]&#34;
KUBE_LABEL_NOT_SAFE_BEGINING_END_CHARS_REGEX = r&#34;^[^a-zA-Z0-9]*|[^a-zA-Z0-9]*$&#34;
KUBE_LABEL_MAX_LENGTH = 52
KUBE_LABEL_REPLACEMENT_CHAR = &#39;-&#39;


class ArgoCD(StepImplementer):
    &#34;&#34;&#34;`StepImplementer` for the `deploy` step using ArgoCD.
    &#34;&#34;&#34;

    GIT_REPO_REGEX = re.compile(r&#34;(?P&lt;protocol&gt;^https:\/\/|^http:\/\/)?(?P&lt;address&gt;.*$)&#34;)

    @staticmethod
    def step_implementer_config_defaults():
        &#34;&#34;&#34;Getter for the StepImplementer&#39;s configuration defaults.

        Returns
        -------
        dict
            Default values to use for step configuration values.

        Notes
        -----
        These are the lowest precedence configuration values.
        &#34;&#34;&#34;
        return DEFAULT_CONFIG

    @staticmethod
    def _required_config_or_result_keys():
        &#34;&#34;&#34;Getter for step configuration or previous step result artifacts that are required before
        running this step.

        See Also
        --------
        _validate_required_config_or_previous_step_result_artifact_keys

        Returns
        -------
        array_list
            Array of configuration keys or previous step result artifacts
            that are required before running the step.
        &#34;&#34;&#34;
        return REQUIRED_CONFIG_OR_PREVIOUS_STEP_RESULT_ARTIFACT_KEYS

    def _validate_required_config_or_previous_step_result_artifact_keys(self):
        &#34;&#34;&#34;Validates that the required configuration keys or previous step result artifacts
        are set and have valid values.

        Validates that:
        * required configuration is given
        * either both git-username and git-password are set or neither.

        Raises
        ------
        StepRunnerException
            If step configuration or previous step result artifacts have invalid required values
        &#34;&#34;&#34;
        super()._validate_required_config_or_previous_step_result_artifact_keys()

        # ensure either both git-username and git-password are set or neither
        runtime_auth_config = {}
        for auth_config_key in GIT_AUTHENTICATION_CONFIG:
            runtime_auth_config_value = self.get_value(auth_config_key)

            if runtime_auth_config_value is not None:
                runtime_auth_config[auth_config_key] = runtime_auth_config_value

        if (any(element in runtime_auth_config for element in GIT_AUTHENTICATION_CONFIG)) and \
                (not all(element in runtime_auth_config for element in GIT_AUTHENTICATION_CONFIG)):
            raise StepRunnerException(
                &#34;Either &#39;git-username&#39; or &#39;git-password &#39;is not set. Neither or both must be set.&#34;
            )

        # ensure if deployment config repo is using http/https that user/pass is provided
        deployment_config_repo_uri = self.get_value(&#39;deployment-config-repo&#39;)
        if re.match(r&#39;^http://|^https://&#39;, deployment_config_repo_uri) and not runtime_auth_config:
            raise StepRunnerException(
                f&#34;Since provided &#39;deployment-config-repo&#39; ({deployment_config_repo_uri}) uses&#34;
                f&#34; http/https protical both &#39;git-username&#39; and &#39;git-password&#39; must be provided.&#34;
            )

    def _run_step(self):  # pylint: disable=too-many-locals
        &#34;&#34;&#34;Runs the step implemented by this StepImplementer.

        Returns
        -------
        StepResult
            Object containing the dictionary results of this step.
        &#34;&#34;&#34;
        step_result = StepResult.from_step_implementer(self)

        # get input
        deployment_config_repo = self.get_value(&#39;deployment-config-repo&#39;)
        deployment_config_repo_branch = ArgoCD.__get_repo_branch()
        deployment_config_helm_chart_path = self.get_value(&#39;deployment-config-helm-chart-path&#39;)
        deployment_config_destination_cluster_uri = self.get_value(&#39;kube-api-uri&#39;)
        deployment_config_destination_cluster_token = self.get_value(&#39;kube-api-token&#39;)
        deployment_config_helm_chart_environment_values_file = \
            self.__get_deployment_config_helm_chart_environment_values_file()
        deployment_config_helm_chart_values_file_image_tag_yq_path = \
            self.get_value(&#39;deployment-config-helm-chart-values-file-image-tag-yq-path&#39;)
        deployment_config_helm_chart_additional_value_files = \
            self.get_value(&#39;deployment-config-helm-chart-additional-values-files&#39;)
        container_image_tag = self.get_value(&#39;container-image-tag&#39;)
        force_push_tags = self.get_value(&#39;force-push-tags&#39;)
        additional_helm_values_files = self.get_value(&#39;additional-helm-values-files&#39;)

        try:
            argocd_app_name = self.__get_app_name()
            step_result.add_artifact(
                name=&#39;argocd-app-name&#39;,
                value=argocd_app_name
            )

            # clone the configuration repository
            print(&#34;Clone the configuration repository&#34;)
            clone_repo_dir_name = &#39;deployment-config-repo&#39;
            deployment_config_repo_dir = ArgoCD.__clone_repo(
                repo_dir=self.create_working_dir_sub_dir(clone_repo_dir_name),
                repo_url=deployment_config_repo,
                repo_branch=deployment_config_repo_branch,
                git_email=self.get_value(&#39;git-email&#39;),
                git_name=self.get_value(&#39;git-name&#39;),
                username = self.get_value(&#39;git-username&#39;),
                password = self.get_value(&#39;git-password&#39;)
            )

            # update values file, commit it, push it, and tag it
            print(&#34;Update the environment values file&#34;)
            deployment_config_helm_chart_environment_values_file_path = os.path.join(
                deployment_config_repo_dir,
                deployment_config_helm_chart_path,
                deployment_config_helm_chart_environment_values_file
            )
            self.__update_yaml_file_value(
                file=deployment_config_helm_chart_environment_values_file_path,
                yq_path=deployment_config_helm_chart_values_file_image_tag_yq_path,
                value=container_image_tag
            )
            print(&#34;Commit the updated environment values file&#34;)
            ArgoCD.__git_commit_file(
                git_commit_message=f&#39;Updating values for deployment to {self.environment}&#39;,
                file_path=os.path.join(
                    deployment_config_helm_chart_path,
                    deployment_config_helm_chart_environment_values_file
                ),
                repo_dir=deployment_config_repo_dir
            )
            print(&#34;Tag and push the updated environment values file&#34;)
            deployment_config_repo_tag = self.__get_deployment_config_repo_tag()
            self.__git_tag_and_push_deployment_config_repo(
                deployment_config_repo=deployment_config_repo,
                deployment_config_repo_dir=deployment_config_repo_dir,
                deployment_config_repo_tag=deployment_config_repo_tag,
                force_push_tags=force_push_tags
            )
            step_result.add_artifact(
                name=&#39;config-repo-git-tag&#39;,
                value=deployment_config_repo_tag
            )

            # create/update argocd app and sync it
            print(&#34;Sign into ArgoCD&#34;)
            ArgoCD.__argocd_sign_in(
                argocd_api=self.get_value(&#39;argocd-api&#39;),
                username=self.get_value(&#39;argocd-username&#39;),
                password=self.get_value(&#39;argocd-password&#39;),
                insecure=self.get_value(&#39;argocd-skip-tls&#39;)
            )
            print(&#34;Add target cluster to ArgoCD&#34;)
            self.__argocd_add_target_cluster(
                kube_api=deployment_config_destination_cluster_uri,
                kube_api_token=deployment_config_destination_cluster_token,
                kube_api_skip_tls=self.get_value(&#39;kube-api-skip-tls&#39;)
            )
            print(f&#34;Create or update ArgoCD Application ({argocd_app_name})&#34;)
            argocd_values_files = []
            argocd_values_files += deployment_config_helm_chart_additional_value_files
            argocd_values_files += [deployment_config_helm_chart_environment_values_file]
            argocd_values_files += additional_helm_values_files
            ArgoCD.__argocd_app_create_or_update(
                argocd_app_name=argocd_app_name,
                repo=deployment_config_repo,
                revision=deployment_config_repo_tag,
                path=deployment_config_helm_chart_path,
                dest_server=deployment_config_destination_cluster_uri,
                auto_sync=self.get_value(&#39;argocd-auto-sync&#39;),
                values_files=argocd_values_files
            )

            # sync and wait for the sync of the ArgoCD app
            print(f&#34;Sync (and wait for) ArgoCD Application ({argocd_app_name})&#34;)
            ArgoCD.__argocd_app_sync(
                argocd_app_name=argocd_app_name,
                argocd_sync_timeout_seconds=self.get_value(&#39;argocd-sync-timeout-seconds&#39;),
                argocd_sync_retry_limit=self.get_value(&#39;argocd-sync-retry-limit&#39;),
                argocd_sync_prune=self.get_value(&#39;argocd-sync-prune&#39;)
            )

            # get the ArgoCD app manifest that was synced
            print(f&#34;Get ArgoCD Application ({argocd_app_name}) synced manifest&#34;)
            argocd_app_manifest_file = self.__argocd_get_app_manifest(
                argocd_app_name=argocd_app_name
            )
            step_result.add_artifact(
                name=&#39;argocd-deployed-manifest&#39;,
                value=argocd_app_manifest_file
            )

            # determine the deployed host URLs
            print(
                &#34;Determine the deployed host URLs for the synced&#34;
                f&#34; ArgoCD Application (({argocd_app_name})&#34;
            )
            deployed_host_urls = ArgoCD.__get_deployed_host_urls(
                manifest_path=argocd_app_manifest_file
            )
            step_result.add_artifact(
                name=&#39;deployed-host-urls&#39;,
                value=deployed_host_urls
            )
        except StepRunnerException as error:
            step_result.success = False
            step_result.message = f&#34;Error deploying to environment ({self.environment}):&#34; \
                f&#34; {str(error)}&#34;

        return step_result

    def __get_deployment_config_helm_chart_environment_values_file(self):
        &#34;&#34;&#34;Get the deployment configuration Helm Chart environment specific value file.

        Returns
        -------
        str
            Deployment configuration Helm Chart environment specific value file.
        &#34;&#34;&#34;
        deployment_config_helm_chart_env_value_file = \
            self.get_value(&#39;deployment-config-helm-chart-environment-values-file&#39;)

        if not deployment_config_helm_chart_env_value_file:
            if self.environment:
                deployment_config_helm_chart_env_value_file = f&#39;values-{self.environment}.yaml&#39;
            else:
                deployment_config_helm_chart_env_value_file = &#39;values.yaml&#39;

        return deployment_config_helm_chart_env_value_file

    def __update_yaml_file_value(self, file, yq_path, value):
        &#34;&#34;&#34;Update a YAML file using YQ.

        Parameters
        ----------
        file : str
            Path to file to update.
        yq_path : str
            YQ path to the value to update.
        value: str
            value to update the `yq_path`

        Returns
        -------
        str
            Path to the file to update.

        Raises
        ------
        StepRunnerException
            If error updating file.
        &#34;&#34;&#34;
        # NOTE: use a YQ script to update so that comment can be injected
        yq_script_file = self.write_working_file(
            filename=&#39;update-yaml-file-yq-script.yaml&#39;,
            contents=bytes(
                f&#34;- command: update\n&#34;
                f&#34;  path: {yq_path}\n&#34;
                f&#34;  value:\n&#34;
                f&#34;    {value} # written by ploigos-step-runner\n&#34;,
                &#39;utf-8&#39;
            )
        )

        # inplace update the file
        try:
            sh.yq.write( # pylint: disable=no-member
                file,
                f&#39;--script={yq_script_file}&#39;,
                &#39;--inplace&#39;
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error updating YAML file ({file}) target ({yq_path}) with value ({value}):&#34;
                f&#34; {error}&#34;
            ) from error

        return file

    def __git_tag_and_push_deployment_config_repo(
        self,
        deployment_config_repo,
        deployment_config_repo_dir,
        deployment_config_repo_tag,
        force_push_tags
    ):
        deployment_config_repo_match = ArgoCD.GIT_REPO_REGEX.match(deployment_config_repo)
        deployment_config_repo_protocol = deployment_config_repo_match.groupdict()[&#39;protocol&#39;]
        deployment_config_repo_address = deployment_config_repo_match.groupdict()[&#39;address&#39;]

        # if deployment config repo uses http/https push using user/pass
        # else push using ssh
        if deployment_config_repo_protocol and re.match(
            r&#39;^http://|^https://&#39;,
            deployment_config_repo_protocol
        ):
            username = self.get_value(&#39;git-username&#39;)
            password = self.get_value(&#39;git-password&#39;)

            deployment_config_repo_with_user_pass = \
                f&#34;{deployment_config_repo_protocol}{username}:{password}&#34; \
                f&#34;@{deployment_config_repo_address}&#34;
            ArgoCD.__git_tag_and_push(
                repo_dir=deployment_config_repo_dir,
                tag=deployment_config_repo_tag,
                url=deployment_config_repo_with_user_pass,
                force_push_tags=force_push_tags
            )
        else:
            ArgoCD.__git_tag_and_push(
                repo_dir=deployment_config_repo_dir,
                tag=deployment_config_repo_tag,
                force_push_tags=force_push_tags
            )

    def __get_app_name(self):
        repo_branch = ArgoCD.__get_repo_branch()
        organization = self.get_value(&#39;organization&#39;)
        application = self.get_value(&#39;application-name&#39;)
        service = self.get_value(&#39;service-name&#39;)
        app_name = f&#34;{organization}-{application}-{service}-{repo_branch}&#34;

        if self.environment:
            app_name = app_name + &#39;-&#39; + self.environment

        # replace dangerous characters in app name
        app_name = app_name.lower()
        app_name = re.sub(
            KUBE_LABEL_NOT_SAFE_CHARS_REGEX,
            KUBE_LABEL_REPLACEMENT_CHAR,
            app_name
        )

        # max length for a kube label / resource name is 63
        if len(app_name) &gt; KUBE_LABEL_MAX_LENGTH:
            app_name = app_name[len(app_name) - KUBE_LABEL_MAX_LENGTH:]

        # be sure app name doesn&#39;t start or end with not safe chars
        app_name = re.sub(
            KUBE_LABEL_NOT_SAFE_BEGINING_END_CHARS_REGEX,
            &#39;&#39;,
            app_name
        )

        return app_name

    def __get_deployment_config_repo_tag(self):
        &#34;&#34;&#34;
        Returns
        -------
        str
            String to tag the deployment configuration repository with.

        Raise
        -----
        StepRunnerException
            If i
        &#34;&#34;&#34;
        tag = self.get_value(&#39;tag&#39;)

        if tag is None:
            tag = self.get_value(&#39;version&#39;)

        if tag is None:
            tag = &#39;latest&#39;
            print(
                &#34;No specified &#39;tag&#39; or &#39;version&#39; using &#39;latest&#39; for&#34;
                &#34;deployment configuration repository tag.&#34;
            )

        # need the config repo tag to be unique per environment to prevent conflicts
        if self.environment:
            tag += f&#34;.{self.environment}&#34;

        return tag

    @staticmethod
    def __get_deployed_host_urls( # pylint: disable=too-many-branches,too-many-nested-blocks
        manifest_path
    ):
        &#34;&#34;&#34;Gets the ingress hosts URLs from a manifest of Kubernetes resources.

        Supports:

        - route.openshift.io/v1/Route
        - networking.k8s.io/v1/Ingress

        Returns
        -------
        list of str
            Ingress hosts URLs defined in the given manifest of Kubernetes resources.

        See
        ---
        * https://docs.openshift.com/container-platform/4.6/rest_api/network_apis/ingress-networking-k8s-io-v1.html
        * https://docs.openshift.com/container-platform/4.6/rest_api/network_apis/route-route-openshift-io-v1.html
        &#34;&#34;&#34; # pylint: disable=line-too-long
        host_urls = []
        manifest_resources = {}
        # load the manifest
        with open(manifest_path, encoding=&#39;utf-8&#39;) as file:
            manifest_resources = yaml.load_all(file, Loader=yaml.FullLoader)

            # for each resource in the manfest,
            # determine if its a known type and then attempt to get host and TLS config from it
            for manifest_resource in manifest_resources:
                if manifest_resource is None or &#39;kind&#39; not in manifest_resource:
                    continue

                kind = manifest_resource[&#39;kind&#39;]
                api_version = manifest_resource[&#39;apiVersion&#39;]

                # if Route resource
                if kind == &#39;Route&#39; and api_version == &#39;route.openshift.io/v1&#39;:
                    # get host
                    if &#39;host&#39; in manifest_resource[&#39;spec&#39;]:
                        host = manifest_resource[&#39;spec&#39;][&#39;host&#39;]

                        # determine if TLS route
                        tls = False
                        if &#39;tls&#39; in manifest_resource[&#39;spec&#39;]:
                            tls_config = manifest_resource[&#39;spec&#39;][&#39;tls&#39;]
                            if tls_config:
                                tls = True

                        # determine protocol
                        protocol = &#39;&#39;
                        if tls:
                            protocol = &#39;https://&#39;
                        else:
                            protocol = &#39;http://&#39;

                        # record the host url
                        host_urls.append(f&#34;{protocol}{host}&#34;)

                # if Ingress resource
                if kind == &#39;Ingress&#39; and api_version == &#39;networking.k8s.io/v1&#39;:
                    ingress_rules = manifest_resource[&#39;spec&#39;][&#39;rules&#39;]
                    for rule in ingress_rules:
                        # get host
                        if &#39;host&#39; in rule:
                            host = rule[&#39;host&#39;]

                            # determine if TLS ingress
                            tls = False
                            if &#39;tls&#39; in manifest_resource[&#39;spec&#39;]:
                                for tls_config in manifest_resource[&#39;spec&#39;][&#39;tls&#39;]:
                                    if (&#39;hosts&#39; in tls_config) and (host in tls_config[&#39;hosts&#39;]):
                                        tls = True
                                        break

                            # determine protocol
                            protocol = &#39;&#39;
                            if tls:
                                protocol = &#39;https://&#39;
                            else:
                                protocol = &#39;http://&#39;

                            # record the host url
                            host_urls.append(f&#34;{protocol}{host}&#34;)

        return host_urls

    @staticmethod
    def __clone_repo( # pylint: disable=too-many-arguments
        repo_dir,
        repo_url,
        repo_branch,
        git_email,
        git_name,
          username=None,
          password=None
    ):
        &#34;&#34;&#34;Clones and checks out the deployment configuration repository.

        Parameters
        ----------
        repo_dir : str
            Path to where to clone the repository
        repo_uri : str
            URI of the repository to clone.
        git_email : str
            email to use when performing git operations in the cloned repository
        git_name : str
            name to use when performing git operations in the cloned repository

        Returns
        -------
        str
            Path to the directory where the deployment configuration repository was cloned
            and checked out.

        Raises
        ------
        StepRunnerException
        * if error cloning repository
        * if error checking out branch of repository
        * if error configuring repo user
        &#34;&#34;&#34;
        repo_match = ArgoCD.GIT_REPO_REGEX.match(repo_url)
        repo_protocol = repo_match.groupdict()[&#39;protocol&#39;]
        repo_address = repo_match.groupdict()[&#39;address&#39;]
        # if deployment config repo uses http/https push using user/pass
        # else push using ssh
        if username and password and repo_protocol and re.match(
            r&#39;^http://|^https://&#39;,
            repo_protocol
        ):
            repo_url_with_auth = \
                f&#34;{repo_protocol}{username}:{password}&#34; \
                f&#34;@{repo_address}&#34;
        else:
            repo_url_with_auth = repo_url
        try:
            sh.git.clone( # pylint: disable=no-member
                repo_url_with_auth,
                repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error cloning repository ({repo_url}): {error}&#34;
            ) from error

        try:
            # no atomic way in git to checkout out new or existing branch,
            # so first try to check out existing, if that doesn&#39;t work try new
            try:
                sh.git.checkout(  # pylint: disable=no-member
                    repo_branch,
                    _cwd=repo_dir,
                    _out=sys.stdout,
                    _err=sys.stderr
                )
            except sh.ErrorReturnCode:
                sh.git.checkout(
                    &#39;-b&#39;,
                    repo_branch,
                    _cwd=repo_dir,
                    _out=sys.stdout,
                    _err=sys.stderr
                )
        except sh.ErrorReturnCode as error:
            # NOTE: this should never happen
            raise StepRunnerException(
                f&#34;Unexpected error checking out new or existing branch ({repo_branch})&#34;
                f&#34; from repository ({repo_url}): {error}&#34;
            ) from error

        try:
            sh.git.config( # pylint: disable=no-member
                &#39;user.email&#39;,
                git_email,
                _cwd=repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
            sh.git.config( # pylint: disable=no-member
                &#39;user.name&#39;,
                git_name,
                _cwd=repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            # NOTE: this should never happen
            raise StepRunnerException(
                f&#34;Unexpected error configuring git user.email ({git_email})&#34;
                f&#34; and user.name ({git_name}) for repository ({repo_url})&#34;
                f&#34; in directory ({repo_dir}): {error}&#34;
            ) from error

        return repo_dir

    @staticmethod
    def __get_repo_branch():
        try:
            return sh.git( # pylint: disable=no-member,too-many-function-args
                &#39;rev-parse&#39;,
                &#39;--abbrev-ref&#39;,
                &#39;HEAD&#39;
            ).rstrip()
        except sh.ErrorReturnCode as error:
            # NOTE: this should never happen
            raise StepRunnerException(
                &#34;Unexpected error getting checkedout git repository branch&#34;
                f&#34; of the working directory: {error}&#34;
            ) from error

    @staticmethod
    def __git_tag_and_push(repo_dir, tag, url=None, force_push_tags=False):
        &#34;&#34;&#34;
        Raises
        ------
        StepRunnerException
        * if error pushing commits
        * if error tagging repository
        * if error pushing tags
        &#34;&#34;&#34;

        git_push = sh.git.push.bake(url) if url else sh.git.push

        # push commits
        try:
            git_push(
                _cwd=repo_dir,
                _out=sys.stdout
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error pushing commits from repository directory ({repo_dir}) to&#34;
                f&#34; repository ({url}): {error}&#34;
            ) from error

        # tag
        try:
            # NOTE:
            # this force is only needed locally in case of a re-run of the same pipeline
            # without a fresh check out. You will notice there is no force on the push
            # making this an acceptable work around to the issue since on the off chance
            # actually overwriting a tag with a different comment, the push will fail
            # because the tag will be attached to a different git hash.
            sh.git.tag(  # pylint: disable=no-member
                tag,
                &#39;-f&#39;,
                _cwd=repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error tagging repository ({repo_dir}) with tag ({tag}): {error}&#34;
            ) from error

        git_push_additional_arguments = []
        if force_push_tags:
            git_push_additional_arguments += [&#34;--force&#34;]

        # push tag
        try:
            git_push(
                &#39;--tag&#39;,
                *git_push_additional_arguments,
                _cwd=repo_dir,
                _out=sys.stdout
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error pushing tags from repository directory ({repo_dir}) to&#34;
                f&#34; repository ({url}): {error}&#34;
            ) from error

    @staticmethod
    def __git_commit_file(git_commit_message, file_path, repo_dir):
        try:
            sh.git.add( # pylint: disable=no-member
                file_path,
                _cwd=repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            # NOTE: this should never happen
            raise StepRunnerException(
                f&#34;Unexpected error adding file ({file_path}) to commit&#34;
                f&#34; in git repository ({repo_dir}): {error}&#34;
            ) from error

        try:
            sh.git.commit( # pylint: disable=no-member
                &#39;--allow-empty&#39;,
                &#39;--all&#39;,
                &#39;--message&#39;, git_commit_message,
                _cwd=repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            # NOTE: this should never happen
            raise StepRunnerException(
                f&#34;Unexpected error commiting file ({file_path})&#34;
                f&#34; in git repository ({repo_dir}): {error}&#34;
            ) from error

    @staticmethod
    def __argocd_sign_in(
        argocd_api,
        username,
        password,
        insecure=False
    ):
        &#34;&#34;&#34;Signs into ArgoCD CLI.

        Raises
        ------
        StepRunnerException
            If error signing into ArgoCD CLI.
        &#34;&#34;&#34;
        try:
            insecure_flag = None
            if insecure:
                insecure_flag = &#39;--insecure&#39;

            sh.argocd.login(  # pylint: disable=no-member
                argocd_api,
                f&#39;--username={username}&#39;,
                f&#39;--password={password}&#39;,
                insecure_flag,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(f&#34;Error logging in to ArgoCD: {error}&#34;) from error

    def __argocd_add_target_cluster(
        self,
        kube_api,
        kube_api_token=None,
        kube_api_skip_tls=False
    ):
        &#34;&#34;&#34;If the target cluster is not the default cluster then add that cluster to ArgoCD.

        **WARNING:*** have not re-integration tested this since refactor. Have a feeling that
        it does not work as expected. I have a feeling there is issues with the context names.

        Raises
        ------
        StepRunnerException
            If error adding cluster to ArgoCD
        &#34;&#34;&#34;
        # If the cluster is an external cluster and an api token was provided,
        # add the cluster to ArgoCD
        if kube_api != DEFAULT_CONFIG[&#39;kube-api-uri&#39;]:
            context_name = f&#39;{kube_api}-context&#39;
            kubeconfig = f&#34;&#34;&#34;---
apiVersion: v1
kind: Config
current-context: {context_name}
clusters:
- cluster:
    insecure-skip-tls-verify: {str(kube_api_skip_tls).lower()}
    server: {kube_api}
  name: default-cluster
contexts:
- context:
    cluster: default-cluster
    user: default-user
  name: {context_name}
preferences:
users:
- name: default-user
  user:
    token: {kube_api_token}
&#34;&#34;&#34;

            config_argocd_cluster_context_file = self.write_working_file(
                filename=&#39;config-argocd-cluster-context.yaml&#39;,
                contents=bytes(kubeconfig, &#39;utf-8&#39;)
            )
            try:
                sh.argocd.cluster.add(  # pylint: disable=no-member
                    &#39;--kubeconfig&#39;, config_argocd_cluster_context_file,
                    context_name,
                    _out=sys.stdout,
                    _err=sys.stderr
                )
            except sh.ErrorReturnCode as error:
                raise StepRunnerException(
                    f&#34;Error adding cluster ({kube_api}) to ArgoCD: {error}&#34;
                ) from error

    @staticmethod
    def __argocd_app_create_or_update( # pylint: disable=too-many-arguments
        argocd_app_name,
        repo,
        revision,
        path,
        dest_server,
        auto_sync,
        values_files
    ):
        &#34;&#34;&#34;Creates or updates an ArgoCD App.

        Raises
        ------
        StepRunnerException
            If error creating or updating ArgoCD app.
        &#34;&#34;&#34;
        try:
            if str(auto_sync).lower() == &#39;true&#39;:
                sync_policy = &#39;automated&#39;
            else:
                sync_policy = &#39;none&#39;

            values_params = None
            if values_files:
                values_params = []
                for value_file in values_files:
                    values_params += [f&#39;--values={value_file}&#39;]

            sh.argocd.app.create(  # pylint: disable=no-member
                argocd_app_name,
                f&#39;--repo={repo}&#39;,
                f&#39;--revision={revision}&#39;,
                f&#39;--path={path}&#39;,
                f&#39;--dest-server={dest_server}&#39;,
                f&#39;--dest-namespace={argocd_app_name}&#39;,
                f&#39;--sync-policy={sync_policy}&#39;,
                values_params,
                &#39;--upsert&#39;,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error creating or updating ArgoCD app ({argocd_app_name}): {error}&#34;
            ) from error

    @staticmethod
    def __argocd_app_sync(
        argocd_app_name,
        argocd_sync_timeout_seconds,
        argocd_sync_retry_limit,
        argocd_sync_prune=True
    ):
        # add any additional flags
        argocd_sync_additional_flags = []
        if argocd_sync_prune:
            argocd_sync_additional_flags.append(&#39;--prune&#39;)

        try:
            sh.argocd.app.sync(  # pylint: disable=no-member
                *argocd_sync_additional_flags,
                &#39;--timeout&#39;, argocd_sync_timeout_seconds,
                &#39;--retry-limit&#39;, argocd_sync_retry_limit,
                argocd_app_name,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            if not argocd_sync_prune:
                prune_warning = &#34;. Sync &#39;prune&#39; option is disabled.&#34; \
                    &#34; If sync error (see logs) was due to resource(s) that need to be pruned,&#34; \
                    &#34; and the pruneable resources are intentionally there then see the ArgoCD&#34; \
                    &#34; documentation for instructions for argo to ignore the resource(s).&#34; \
                    &#34; See: https://argoproj.github.io/argo-cd/user-guide/sync-options/#no-prune-resources&#34; \
                    &#34; and https://argoproj.github.io/argo-cd/user-guide/compare-options/#ignoring-resources-that-are-extraneous&#34;
            else:
                prune_warning = &#34;&#34;

            raise StepRunnerException(
                f&#34;Error synchronization ArgoCD Application ({argocd_app_name})&#34;
                f&#34;{prune_warning}: {error}&#34;
            ) from error

        try:
            sh.argocd.app.wait(  # pylint: disable=no-member
                &#39;--timeout&#39;, argocd_sync_timeout_seconds,
                &#39;--health&#39;,
                argocd_app_name,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error waiting for ArgoCD Application ({argocd_app_name}) synchronization: {error}&#34;
            ) from error

    def __argocd_get_app_manifest(
        self,
        argocd_app_name,
        source=&#39;live&#39;
    ):
        &#34;&#34;&#34;Get ArgoCD Application manifest.

        Parameters
        ----------
        argocd_app_name : str
            Name of the ArgoCD Application to get the manifest for.
        source : str (live,git)
            Get the manifest from the &#39;live&#39; version of the &#39;git&#39; version.

        Returns
        -------
        str
            Path to the retrieved ArgoCD manifest file.

        Raises
        ------
        StepRunnerException
            If error getting ArgoCD manifest.
        &#34;&#34;&#34;
        argocd_app_manifest_file = self.write_working_file(&#39;deploy_argocd_manifests.yml&#39;)
        try:
            sh.argocd.app.manifests(  # pylint: disable=no-member
                f&#39;--source={source}&#39;,
                argocd_app_name,
                _out=argocd_app_manifest_file,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error reading ArgoCD Application ({argocd_app_name}) manifest: {error}&#34;
            ) from error

        return argocd_app_manifest_file</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ploigos_step_runner.step_implementers.deploy.argocd.ArgoCD"><code class="flex name class">
<span>class <span class="ident">ArgoCD</span></span>
<span>(</span><span>workflow_result, parent_work_dir_path, config, environment=None)</span>
</code></dt>
<dd>
<div class="desc"><p><code>StepImplementer</code> for the <code>deploy</code> step using ArgoCD.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArgoCD(StepImplementer):
    &#34;&#34;&#34;`StepImplementer` for the `deploy` step using ArgoCD.
    &#34;&#34;&#34;

    GIT_REPO_REGEX = re.compile(r&#34;(?P&lt;protocol&gt;^https:\/\/|^http:\/\/)?(?P&lt;address&gt;.*$)&#34;)

    @staticmethod
    def step_implementer_config_defaults():
        &#34;&#34;&#34;Getter for the StepImplementer&#39;s configuration defaults.

        Returns
        -------
        dict
            Default values to use for step configuration values.

        Notes
        -----
        These are the lowest precedence configuration values.
        &#34;&#34;&#34;
        return DEFAULT_CONFIG

    @staticmethod
    def _required_config_or_result_keys():
        &#34;&#34;&#34;Getter for step configuration or previous step result artifacts that are required before
        running this step.

        See Also
        --------
        _validate_required_config_or_previous_step_result_artifact_keys

        Returns
        -------
        array_list
            Array of configuration keys or previous step result artifacts
            that are required before running the step.
        &#34;&#34;&#34;
        return REQUIRED_CONFIG_OR_PREVIOUS_STEP_RESULT_ARTIFACT_KEYS

    def _validate_required_config_or_previous_step_result_artifact_keys(self):
        &#34;&#34;&#34;Validates that the required configuration keys or previous step result artifacts
        are set and have valid values.

        Validates that:
        * required configuration is given
        * either both git-username and git-password are set or neither.

        Raises
        ------
        StepRunnerException
            If step configuration or previous step result artifacts have invalid required values
        &#34;&#34;&#34;
        super()._validate_required_config_or_previous_step_result_artifact_keys()

        # ensure either both git-username and git-password are set or neither
        runtime_auth_config = {}
        for auth_config_key in GIT_AUTHENTICATION_CONFIG:
            runtime_auth_config_value = self.get_value(auth_config_key)

            if runtime_auth_config_value is not None:
                runtime_auth_config[auth_config_key] = runtime_auth_config_value

        if (any(element in runtime_auth_config for element in GIT_AUTHENTICATION_CONFIG)) and \
                (not all(element in runtime_auth_config for element in GIT_AUTHENTICATION_CONFIG)):
            raise StepRunnerException(
                &#34;Either &#39;git-username&#39; or &#39;git-password &#39;is not set. Neither or both must be set.&#34;
            )

        # ensure if deployment config repo is using http/https that user/pass is provided
        deployment_config_repo_uri = self.get_value(&#39;deployment-config-repo&#39;)
        if re.match(r&#39;^http://|^https://&#39;, deployment_config_repo_uri) and not runtime_auth_config:
            raise StepRunnerException(
                f&#34;Since provided &#39;deployment-config-repo&#39; ({deployment_config_repo_uri}) uses&#34;
                f&#34; http/https protical both &#39;git-username&#39; and &#39;git-password&#39; must be provided.&#34;
            )

    def _run_step(self):  # pylint: disable=too-many-locals
        &#34;&#34;&#34;Runs the step implemented by this StepImplementer.

        Returns
        -------
        StepResult
            Object containing the dictionary results of this step.
        &#34;&#34;&#34;
        step_result = StepResult.from_step_implementer(self)

        # get input
        deployment_config_repo = self.get_value(&#39;deployment-config-repo&#39;)
        deployment_config_repo_branch = ArgoCD.__get_repo_branch()
        deployment_config_helm_chart_path = self.get_value(&#39;deployment-config-helm-chart-path&#39;)
        deployment_config_destination_cluster_uri = self.get_value(&#39;kube-api-uri&#39;)
        deployment_config_destination_cluster_token = self.get_value(&#39;kube-api-token&#39;)
        deployment_config_helm_chart_environment_values_file = \
            self.__get_deployment_config_helm_chart_environment_values_file()
        deployment_config_helm_chart_values_file_image_tag_yq_path = \
            self.get_value(&#39;deployment-config-helm-chart-values-file-image-tag-yq-path&#39;)
        deployment_config_helm_chart_additional_value_files = \
            self.get_value(&#39;deployment-config-helm-chart-additional-values-files&#39;)
        container_image_tag = self.get_value(&#39;container-image-tag&#39;)
        force_push_tags = self.get_value(&#39;force-push-tags&#39;)
        additional_helm_values_files = self.get_value(&#39;additional-helm-values-files&#39;)

        try:
            argocd_app_name = self.__get_app_name()
            step_result.add_artifact(
                name=&#39;argocd-app-name&#39;,
                value=argocd_app_name
            )

            # clone the configuration repository
            print(&#34;Clone the configuration repository&#34;)
            clone_repo_dir_name = &#39;deployment-config-repo&#39;
            deployment_config_repo_dir = ArgoCD.__clone_repo(
                repo_dir=self.create_working_dir_sub_dir(clone_repo_dir_name),
                repo_url=deployment_config_repo,
                repo_branch=deployment_config_repo_branch,
                git_email=self.get_value(&#39;git-email&#39;),
                git_name=self.get_value(&#39;git-name&#39;),
                username = self.get_value(&#39;git-username&#39;),
                password = self.get_value(&#39;git-password&#39;)
            )

            # update values file, commit it, push it, and tag it
            print(&#34;Update the environment values file&#34;)
            deployment_config_helm_chart_environment_values_file_path = os.path.join(
                deployment_config_repo_dir,
                deployment_config_helm_chart_path,
                deployment_config_helm_chart_environment_values_file
            )
            self.__update_yaml_file_value(
                file=deployment_config_helm_chart_environment_values_file_path,
                yq_path=deployment_config_helm_chart_values_file_image_tag_yq_path,
                value=container_image_tag
            )
            print(&#34;Commit the updated environment values file&#34;)
            ArgoCD.__git_commit_file(
                git_commit_message=f&#39;Updating values for deployment to {self.environment}&#39;,
                file_path=os.path.join(
                    deployment_config_helm_chart_path,
                    deployment_config_helm_chart_environment_values_file
                ),
                repo_dir=deployment_config_repo_dir
            )
            print(&#34;Tag and push the updated environment values file&#34;)
            deployment_config_repo_tag = self.__get_deployment_config_repo_tag()
            self.__git_tag_and_push_deployment_config_repo(
                deployment_config_repo=deployment_config_repo,
                deployment_config_repo_dir=deployment_config_repo_dir,
                deployment_config_repo_tag=deployment_config_repo_tag,
                force_push_tags=force_push_tags
            )
            step_result.add_artifact(
                name=&#39;config-repo-git-tag&#39;,
                value=deployment_config_repo_tag
            )

            # create/update argocd app and sync it
            print(&#34;Sign into ArgoCD&#34;)
            ArgoCD.__argocd_sign_in(
                argocd_api=self.get_value(&#39;argocd-api&#39;),
                username=self.get_value(&#39;argocd-username&#39;),
                password=self.get_value(&#39;argocd-password&#39;),
                insecure=self.get_value(&#39;argocd-skip-tls&#39;)
            )
            print(&#34;Add target cluster to ArgoCD&#34;)
            self.__argocd_add_target_cluster(
                kube_api=deployment_config_destination_cluster_uri,
                kube_api_token=deployment_config_destination_cluster_token,
                kube_api_skip_tls=self.get_value(&#39;kube-api-skip-tls&#39;)
            )
            print(f&#34;Create or update ArgoCD Application ({argocd_app_name})&#34;)
            argocd_values_files = []
            argocd_values_files += deployment_config_helm_chart_additional_value_files
            argocd_values_files += [deployment_config_helm_chart_environment_values_file]
            argocd_values_files += additional_helm_values_files
            ArgoCD.__argocd_app_create_or_update(
                argocd_app_name=argocd_app_name,
                repo=deployment_config_repo,
                revision=deployment_config_repo_tag,
                path=deployment_config_helm_chart_path,
                dest_server=deployment_config_destination_cluster_uri,
                auto_sync=self.get_value(&#39;argocd-auto-sync&#39;),
                values_files=argocd_values_files
            )

            # sync and wait for the sync of the ArgoCD app
            print(f&#34;Sync (and wait for) ArgoCD Application ({argocd_app_name})&#34;)
            ArgoCD.__argocd_app_sync(
                argocd_app_name=argocd_app_name,
                argocd_sync_timeout_seconds=self.get_value(&#39;argocd-sync-timeout-seconds&#39;),
                argocd_sync_retry_limit=self.get_value(&#39;argocd-sync-retry-limit&#39;),
                argocd_sync_prune=self.get_value(&#39;argocd-sync-prune&#39;)
            )

            # get the ArgoCD app manifest that was synced
            print(f&#34;Get ArgoCD Application ({argocd_app_name}) synced manifest&#34;)
            argocd_app_manifest_file = self.__argocd_get_app_manifest(
                argocd_app_name=argocd_app_name
            )
            step_result.add_artifact(
                name=&#39;argocd-deployed-manifest&#39;,
                value=argocd_app_manifest_file
            )

            # determine the deployed host URLs
            print(
                &#34;Determine the deployed host URLs for the synced&#34;
                f&#34; ArgoCD Application (({argocd_app_name})&#34;
            )
            deployed_host_urls = ArgoCD.__get_deployed_host_urls(
                manifest_path=argocd_app_manifest_file
            )
            step_result.add_artifact(
                name=&#39;deployed-host-urls&#39;,
                value=deployed_host_urls
            )
        except StepRunnerException as error:
            step_result.success = False
            step_result.message = f&#34;Error deploying to environment ({self.environment}):&#34; \
                f&#34; {str(error)}&#34;

        return step_result

    def __get_deployment_config_helm_chart_environment_values_file(self):
        &#34;&#34;&#34;Get the deployment configuration Helm Chart environment specific value file.

        Returns
        -------
        str
            Deployment configuration Helm Chart environment specific value file.
        &#34;&#34;&#34;
        deployment_config_helm_chart_env_value_file = \
            self.get_value(&#39;deployment-config-helm-chart-environment-values-file&#39;)

        if not deployment_config_helm_chart_env_value_file:
            if self.environment:
                deployment_config_helm_chart_env_value_file = f&#39;values-{self.environment}.yaml&#39;
            else:
                deployment_config_helm_chart_env_value_file = &#39;values.yaml&#39;

        return deployment_config_helm_chart_env_value_file

    def __update_yaml_file_value(self, file, yq_path, value):
        &#34;&#34;&#34;Update a YAML file using YQ.

        Parameters
        ----------
        file : str
            Path to file to update.
        yq_path : str
            YQ path to the value to update.
        value: str
            value to update the `yq_path`

        Returns
        -------
        str
            Path to the file to update.

        Raises
        ------
        StepRunnerException
            If error updating file.
        &#34;&#34;&#34;
        # NOTE: use a YQ script to update so that comment can be injected
        yq_script_file = self.write_working_file(
            filename=&#39;update-yaml-file-yq-script.yaml&#39;,
            contents=bytes(
                f&#34;- command: update\n&#34;
                f&#34;  path: {yq_path}\n&#34;
                f&#34;  value:\n&#34;
                f&#34;    {value} # written by ploigos-step-runner\n&#34;,
                &#39;utf-8&#39;
            )
        )

        # inplace update the file
        try:
            sh.yq.write( # pylint: disable=no-member
                file,
                f&#39;--script={yq_script_file}&#39;,
                &#39;--inplace&#39;
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error updating YAML file ({file}) target ({yq_path}) with value ({value}):&#34;
                f&#34; {error}&#34;
            ) from error

        return file

    def __git_tag_and_push_deployment_config_repo(
        self,
        deployment_config_repo,
        deployment_config_repo_dir,
        deployment_config_repo_tag,
        force_push_tags
    ):
        deployment_config_repo_match = ArgoCD.GIT_REPO_REGEX.match(deployment_config_repo)
        deployment_config_repo_protocol = deployment_config_repo_match.groupdict()[&#39;protocol&#39;]
        deployment_config_repo_address = deployment_config_repo_match.groupdict()[&#39;address&#39;]

        # if deployment config repo uses http/https push using user/pass
        # else push using ssh
        if deployment_config_repo_protocol and re.match(
            r&#39;^http://|^https://&#39;,
            deployment_config_repo_protocol
        ):
            username = self.get_value(&#39;git-username&#39;)
            password = self.get_value(&#39;git-password&#39;)

            deployment_config_repo_with_user_pass = \
                f&#34;{deployment_config_repo_protocol}{username}:{password}&#34; \
                f&#34;@{deployment_config_repo_address}&#34;
            ArgoCD.__git_tag_and_push(
                repo_dir=deployment_config_repo_dir,
                tag=deployment_config_repo_tag,
                url=deployment_config_repo_with_user_pass,
                force_push_tags=force_push_tags
            )
        else:
            ArgoCD.__git_tag_and_push(
                repo_dir=deployment_config_repo_dir,
                tag=deployment_config_repo_tag,
                force_push_tags=force_push_tags
            )

    def __get_app_name(self):
        repo_branch = ArgoCD.__get_repo_branch()
        organization = self.get_value(&#39;organization&#39;)
        application = self.get_value(&#39;application-name&#39;)
        service = self.get_value(&#39;service-name&#39;)
        app_name = f&#34;{organization}-{application}-{service}-{repo_branch}&#34;

        if self.environment:
            app_name = app_name + &#39;-&#39; + self.environment

        # replace dangerous characters in app name
        app_name = app_name.lower()
        app_name = re.sub(
            KUBE_LABEL_NOT_SAFE_CHARS_REGEX,
            KUBE_LABEL_REPLACEMENT_CHAR,
            app_name
        )

        # max length for a kube label / resource name is 63
        if len(app_name) &gt; KUBE_LABEL_MAX_LENGTH:
            app_name = app_name[len(app_name) - KUBE_LABEL_MAX_LENGTH:]

        # be sure app name doesn&#39;t start or end with not safe chars
        app_name = re.sub(
            KUBE_LABEL_NOT_SAFE_BEGINING_END_CHARS_REGEX,
            &#39;&#39;,
            app_name
        )

        return app_name

    def __get_deployment_config_repo_tag(self):
        &#34;&#34;&#34;
        Returns
        -------
        str
            String to tag the deployment configuration repository with.

        Raise
        -----
        StepRunnerException
            If i
        &#34;&#34;&#34;
        tag = self.get_value(&#39;tag&#39;)

        if tag is None:
            tag = self.get_value(&#39;version&#39;)

        if tag is None:
            tag = &#39;latest&#39;
            print(
                &#34;No specified &#39;tag&#39; or &#39;version&#39; using &#39;latest&#39; for&#34;
                &#34;deployment configuration repository tag.&#34;
            )

        # need the config repo tag to be unique per environment to prevent conflicts
        if self.environment:
            tag += f&#34;.{self.environment}&#34;

        return tag

    @staticmethod
    def __get_deployed_host_urls( # pylint: disable=too-many-branches,too-many-nested-blocks
        manifest_path
    ):
        &#34;&#34;&#34;Gets the ingress hosts URLs from a manifest of Kubernetes resources.

        Supports:

        - route.openshift.io/v1/Route
        - networking.k8s.io/v1/Ingress

        Returns
        -------
        list of str
            Ingress hosts URLs defined in the given manifest of Kubernetes resources.

        See
        ---
        * https://docs.openshift.com/container-platform/4.6/rest_api/network_apis/ingress-networking-k8s-io-v1.html
        * https://docs.openshift.com/container-platform/4.6/rest_api/network_apis/route-route-openshift-io-v1.html
        &#34;&#34;&#34; # pylint: disable=line-too-long
        host_urls = []
        manifest_resources = {}
        # load the manifest
        with open(manifest_path, encoding=&#39;utf-8&#39;) as file:
            manifest_resources = yaml.load_all(file, Loader=yaml.FullLoader)

            # for each resource in the manfest,
            # determine if its a known type and then attempt to get host and TLS config from it
            for manifest_resource in manifest_resources:
                if manifest_resource is None or &#39;kind&#39; not in manifest_resource:
                    continue

                kind = manifest_resource[&#39;kind&#39;]
                api_version = manifest_resource[&#39;apiVersion&#39;]

                # if Route resource
                if kind == &#39;Route&#39; and api_version == &#39;route.openshift.io/v1&#39;:
                    # get host
                    if &#39;host&#39; in manifest_resource[&#39;spec&#39;]:
                        host = manifest_resource[&#39;spec&#39;][&#39;host&#39;]

                        # determine if TLS route
                        tls = False
                        if &#39;tls&#39; in manifest_resource[&#39;spec&#39;]:
                            tls_config = manifest_resource[&#39;spec&#39;][&#39;tls&#39;]
                            if tls_config:
                                tls = True

                        # determine protocol
                        protocol = &#39;&#39;
                        if tls:
                            protocol = &#39;https://&#39;
                        else:
                            protocol = &#39;http://&#39;

                        # record the host url
                        host_urls.append(f&#34;{protocol}{host}&#34;)

                # if Ingress resource
                if kind == &#39;Ingress&#39; and api_version == &#39;networking.k8s.io/v1&#39;:
                    ingress_rules = manifest_resource[&#39;spec&#39;][&#39;rules&#39;]
                    for rule in ingress_rules:
                        # get host
                        if &#39;host&#39; in rule:
                            host = rule[&#39;host&#39;]

                            # determine if TLS ingress
                            tls = False
                            if &#39;tls&#39; in manifest_resource[&#39;spec&#39;]:
                                for tls_config in manifest_resource[&#39;spec&#39;][&#39;tls&#39;]:
                                    if (&#39;hosts&#39; in tls_config) and (host in tls_config[&#39;hosts&#39;]):
                                        tls = True
                                        break

                            # determine protocol
                            protocol = &#39;&#39;
                            if tls:
                                protocol = &#39;https://&#39;
                            else:
                                protocol = &#39;http://&#39;

                            # record the host url
                            host_urls.append(f&#34;{protocol}{host}&#34;)

        return host_urls

    @staticmethod
    def __clone_repo( # pylint: disable=too-many-arguments
        repo_dir,
        repo_url,
        repo_branch,
        git_email,
        git_name,
          username=None,
          password=None
    ):
        &#34;&#34;&#34;Clones and checks out the deployment configuration repository.

        Parameters
        ----------
        repo_dir : str
            Path to where to clone the repository
        repo_uri : str
            URI of the repository to clone.
        git_email : str
            email to use when performing git operations in the cloned repository
        git_name : str
            name to use when performing git operations in the cloned repository

        Returns
        -------
        str
            Path to the directory where the deployment configuration repository was cloned
            and checked out.

        Raises
        ------
        StepRunnerException
        * if error cloning repository
        * if error checking out branch of repository
        * if error configuring repo user
        &#34;&#34;&#34;
        repo_match = ArgoCD.GIT_REPO_REGEX.match(repo_url)
        repo_protocol = repo_match.groupdict()[&#39;protocol&#39;]
        repo_address = repo_match.groupdict()[&#39;address&#39;]
        # if deployment config repo uses http/https push using user/pass
        # else push using ssh
        if username and password and repo_protocol and re.match(
            r&#39;^http://|^https://&#39;,
            repo_protocol
        ):
            repo_url_with_auth = \
                f&#34;{repo_protocol}{username}:{password}&#34; \
                f&#34;@{repo_address}&#34;
        else:
            repo_url_with_auth = repo_url
        try:
            sh.git.clone( # pylint: disable=no-member
                repo_url_with_auth,
                repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error cloning repository ({repo_url}): {error}&#34;
            ) from error

        try:
            # no atomic way in git to checkout out new or existing branch,
            # so first try to check out existing, if that doesn&#39;t work try new
            try:
                sh.git.checkout(  # pylint: disable=no-member
                    repo_branch,
                    _cwd=repo_dir,
                    _out=sys.stdout,
                    _err=sys.stderr
                )
            except sh.ErrorReturnCode:
                sh.git.checkout(
                    &#39;-b&#39;,
                    repo_branch,
                    _cwd=repo_dir,
                    _out=sys.stdout,
                    _err=sys.stderr
                )
        except sh.ErrorReturnCode as error:
            # NOTE: this should never happen
            raise StepRunnerException(
                f&#34;Unexpected error checking out new or existing branch ({repo_branch})&#34;
                f&#34; from repository ({repo_url}): {error}&#34;
            ) from error

        try:
            sh.git.config( # pylint: disable=no-member
                &#39;user.email&#39;,
                git_email,
                _cwd=repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
            sh.git.config( # pylint: disable=no-member
                &#39;user.name&#39;,
                git_name,
                _cwd=repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            # NOTE: this should never happen
            raise StepRunnerException(
                f&#34;Unexpected error configuring git user.email ({git_email})&#34;
                f&#34; and user.name ({git_name}) for repository ({repo_url})&#34;
                f&#34; in directory ({repo_dir}): {error}&#34;
            ) from error

        return repo_dir

    @staticmethod
    def __get_repo_branch():
        try:
            return sh.git( # pylint: disable=no-member,too-many-function-args
                &#39;rev-parse&#39;,
                &#39;--abbrev-ref&#39;,
                &#39;HEAD&#39;
            ).rstrip()
        except sh.ErrorReturnCode as error:
            # NOTE: this should never happen
            raise StepRunnerException(
                &#34;Unexpected error getting checkedout git repository branch&#34;
                f&#34; of the working directory: {error}&#34;
            ) from error

    @staticmethod
    def __git_tag_and_push(repo_dir, tag, url=None, force_push_tags=False):
        &#34;&#34;&#34;
        Raises
        ------
        StepRunnerException
        * if error pushing commits
        * if error tagging repository
        * if error pushing tags
        &#34;&#34;&#34;

        git_push = sh.git.push.bake(url) if url else sh.git.push

        # push commits
        try:
            git_push(
                _cwd=repo_dir,
                _out=sys.stdout
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error pushing commits from repository directory ({repo_dir}) to&#34;
                f&#34; repository ({url}): {error}&#34;
            ) from error

        # tag
        try:
            # NOTE:
            # this force is only needed locally in case of a re-run of the same pipeline
            # without a fresh check out. You will notice there is no force on the push
            # making this an acceptable work around to the issue since on the off chance
            # actually overwriting a tag with a different comment, the push will fail
            # because the tag will be attached to a different git hash.
            sh.git.tag(  # pylint: disable=no-member
                tag,
                &#39;-f&#39;,
                _cwd=repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error tagging repository ({repo_dir}) with tag ({tag}): {error}&#34;
            ) from error

        git_push_additional_arguments = []
        if force_push_tags:
            git_push_additional_arguments += [&#34;--force&#34;]

        # push tag
        try:
            git_push(
                &#39;--tag&#39;,
                *git_push_additional_arguments,
                _cwd=repo_dir,
                _out=sys.stdout
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error pushing tags from repository directory ({repo_dir}) to&#34;
                f&#34; repository ({url}): {error}&#34;
            ) from error

    @staticmethod
    def __git_commit_file(git_commit_message, file_path, repo_dir):
        try:
            sh.git.add( # pylint: disable=no-member
                file_path,
                _cwd=repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            # NOTE: this should never happen
            raise StepRunnerException(
                f&#34;Unexpected error adding file ({file_path}) to commit&#34;
                f&#34; in git repository ({repo_dir}): {error}&#34;
            ) from error

        try:
            sh.git.commit( # pylint: disable=no-member
                &#39;--allow-empty&#39;,
                &#39;--all&#39;,
                &#39;--message&#39;, git_commit_message,
                _cwd=repo_dir,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            # NOTE: this should never happen
            raise StepRunnerException(
                f&#34;Unexpected error commiting file ({file_path})&#34;
                f&#34; in git repository ({repo_dir}): {error}&#34;
            ) from error

    @staticmethod
    def __argocd_sign_in(
        argocd_api,
        username,
        password,
        insecure=False
    ):
        &#34;&#34;&#34;Signs into ArgoCD CLI.

        Raises
        ------
        StepRunnerException
            If error signing into ArgoCD CLI.
        &#34;&#34;&#34;
        try:
            insecure_flag = None
            if insecure:
                insecure_flag = &#39;--insecure&#39;

            sh.argocd.login(  # pylint: disable=no-member
                argocd_api,
                f&#39;--username={username}&#39;,
                f&#39;--password={password}&#39;,
                insecure_flag,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(f&#34;Error logging in to ArgoCD: {error}&#34;) from error

    def __argocd_add_target_cluster(
        self,
        kube_api,
        kube_api_token=None,
        kube_api_skip_tls=False
    ):
        &#34;&#34;&#34;If the target cluster is not the default cluster then add that cluster to ArgoCD.

        **WARNING:*** have not re-integration tested this since refactor. Have a feeling that
        it does not work as expected. I have a feeling there is issues with the context names.

        Raises
        ------
        StepRunnerException
            If error adding cluster to ArgoCD
        &#34;&#34;&#34;
        # If the cluster is an external cluster and an api token was provided,
        # add the cluster to ArgoCD
        if kube_api != DEFAULT_CONFIG[&#39;kube-api-uri&#39;]:
            context_name = f&#39;{kube_api}-context&#39;
            kubeconfig = f&#34;&#34;&#34;---
apiVersion: v1
kind: Config
current-context: {context_name}
clusters:
- cluster:
    insecure-skip-tls-verify: {str(kube_api_skip_tls).lower()}
    server: {kube_api}
  name: default-cluster
contexts:
- context:
    cluster: default-cluster
    user: default-user
  name: {context_name}
preferences:
users:
- name: default-user
  user:
    token: {kube_api_token}
&#34;&#34;&#34;

            config_argocd_cluster_context_file = self.write_working_file(
                filename=&#39;config-argocd-cluster-context.yaml&#39;,
                contents=bytes(kubeconfig, &#39;utf-8&#39;)
            )
            try:
                sh.argocd.cluster.add(  # pylint: disable=no-member
                    &#39;--kubeconfig&#39;, config_argocd_cluster_context_file,
                    context_name,
                    _out=sys.stdout,
                    _err=sys.stderr
                )
            except sh.ErrorReturnCode as error:
                raise StepRunnerException(
                    f&#34;Error adding cluster ({kube_api}) to ArgoCD: {error}&#34;
                ) from error

    @staticmethod
    def __argocd_app_create_or_update( # pylint: disable=too-many-arguments
        argocd_app_name,
        repo,
        revision,
        path,
        dest_server,
        auto_sync,
        values_files
    ):
        &#34;&#34;&#34;Creates or updates an ArgoCD App.

        Raises
        ------
        StepRunnerException
            If error creating or updating ArgoCD app.
        &#34;&#34;&#34;
        try:
            if str(auto_sync).lower() == &#39;true&#39;:
                sync_policy = &#39;automated&#39;
            else:
                sync_policy = &#39;none&#39;

            values_params = None
            if values_files:
                values_params = []
                for value_file in values_files:
                    values_params += [f&#39;--values={value_file}&#39;]

            sh.argocd.app.create(  # pylint: disable=no-member
                argocd_app_name,
                f&#39;--repo={repo}&#39;,
                f&#39;--revision={revision}&#39;,
                f&#39;--path={path}&#39;,
                f&#39;--dest-server={dest_server}&#39;,
                f&#39;--dest-namespace={argocd_app_name}&#39;,
                f&#39;--sync-policy={sync_policy}&#39;,
                values_params,
                &#39;--upsert&#39;,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error creating or updating ArgoCD app ({argocd_app_name}): {error}&#34;
            ) from error

    @staticmethod
    def __argocd_app_sync(
        argocd_app_name,
        argocd_sync_timeout_seconds,
        argocd_sync_retry_limit,
        argocd_sync_prune=True
    ):
        # add any additional flags
        argocd_sync_additional_flags = []
        if argocd_sync_prune:
            argocd_sync_additional_flags.append(&#39;--prune&#39;)

        try:
            sh.argocd.app.sync(  # pylint: disable=no-member
                *argocd_sync_additional_flags,
                &#39;--timeout&#39;, argocd_sync_timeout_seconds,
                &#39;--retry-limit&#39;, argocd_sync_retry_limit,
                argocd_app_name,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            if not argocd_sync_prune:
                prune_warning = &#34;. Sync &#39;prune&#39; option is disabled.&#34; \
                    &#34; If sync error (see logs) was due to resource(s) that need to be pruned,&#34; \
                    &#34; and the pruneable resources are intentionally there then see the ArgoCD&#34; \
                    &#34; documentation for instructions for argo to ignore the resource(s).&#34; \
                    &#34; See: https://argoproj.github.io/argo-cd/user-guide/sync-options/#no-prune-resources&#34; \
                    &#34; and https://argoproj.github.io/argo-cd/user-guide/compare-options/#ignoring-resources-that-are-extraneous&#34;
            else:
                prune_warning = &#34;&#34;

            raise StepRunnerException(
                f&#34;Error synchronization ArgoCD Application ({argocd_app_name})&#34;
                f&#34;{prune_warning}: {error}&#34;
            ) from error

        try:
            sh.argocd.app.wait(  # pylint: disable=no-member
                &#39;--timeout&#39;, argocd_sync_timeout_seconds,
                &#39;--health&#39;,
                argocd_app_name,
                _out=sys.stdout,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error waiting for ArgoCD Application ({argocd_app_name}) synchronization: {error}&#34;
            ) from error

    def __argocd_get_app_manifest(
        self,
        argocd_app_name,
        source=&#39;live&#39;
    ):
        &#34;&#34;&#34;Get ArgoCD Application manifest.

        Parameters
        ----------
        argocd_app_name : str
            Name of the ArgoCD Application to get the manifest for.
        source : str (live,git)
            Get the manifest from the &#39;live&#39; version of the &#39;git&#39; version.

        Returns
        -------
        str
            Path to the retrieved ArgoCD manifest file.

        Raises
        ------
        StepRunnerException
            If error getting ArgoCD manifest.
        &#34;&#34;&#34;
        argocd_app_manifest_file = self.write_working_file(&#39;deploy_argocd_manifests.yml&#39;)
        try:
            sh.argocd.app.manifests(  # pylint: disable=no-member
                f&#39;--source={source}&#39;,
                argocd_app_name,
                _out=argocd_app_manifest_file,
                _err=sys.stderr
            )
        except sh.ErrorReturnCode as error:
            raise StepRunnerException(
                f&#34;Error reading ArgoCD Application ({argocd_app_name}) manifest: {error}&#34;
            ) from error

        return argocd_app_manifest_file</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ploigos_step_runner.step_implementer.StepImplementer" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer">StepImplementer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ploigos_step_runner.step_implementers.deploy.argocd.ArgoCD.GIT_REPO_REGEX"><code class="name">var <span class="ident">GIT_REPO_REGEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="ploigos_step_runner.step_implementers.deploy.argocd.ArgoCD.step_implementer_config_defaults"><code class="name flex">
<span>def <span class="ident">step_implementer_config_defaults</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Getter for the StepImplementer's configuration defaults.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Default values to use for step configuration values.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>These are the lowest precedence configuration values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def step_implementer_config_defaults():
    &#34;&#34;&#34;Getter for the StepImplementer&#39;s configuration defaults.

    Returns
    -------
    dict
        Default values to use for step configuration values.

    Notes
    -----
    These are the lowest precedence configuration values.
    &#34;&#34;&#34;
    return DEFAULT_CONFIG</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ploigos_step_runner.step_implementer.StepImplementer" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer">StepImplementer</a></b></code>:
<ul class="hlist">
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.config" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.config">config</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.create_working_dir_sub_dir" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.create_working_dir_sub_dir">create_working_dir_sub_dir</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.environment" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.environment">environment</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.get_config_value" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.get_config_value">get_config_value</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.get_copy_of_runtime_step_config" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.get_copy_of_runtime_step_config">get_copy_of_runtime_step_config</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.get_result_value" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.get_result_value">get_result_value</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.get_value" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.get_value">get_value</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.global_config_defaults" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.global_config_defaults">global_config_defaults</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.global_environment_config_defaults" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.global_environment_config_defaults">global_environment_config_defaults</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.has_config_value" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.has_config_value">has_config_value</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.run_step" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.run_step">run_step</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.step_config" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.step_config">step_config</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.step_config_overrides" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.step_config_overrides">step_config_overrides</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.step_environment_config" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.step_environment_config">step_environment_config</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.step_name" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.step_name">step_name</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.sub_step_implementer_name" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.sub_step_implementer_name">sub_step_implementer_name</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.sub_step_name" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.sub_step_name">sub_step_name</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.work_dir_path" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.work_dir_path">work_dir_path</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.workflow_result" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.workflow_result">workflow_result</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementer.StepImplementer.write_working_file" href="../../step_implementer.html#ploigos_step_runner.step_implementer.StepImplementer.write_working_file">write_working_file</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#step-configuration">Step Configuration</a></li>
<li><a href="#results">Results</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ploigos_step_runner.step_implementers.deploy" href="index.html">ploigos_step_runner.step_implementers.deploy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ploigos_step_runner.step_implementers.deploy.argocd.ArgoCD" href="#ploigos_step_runner.step_implementers.deploy.argocd.ArgoCD">ArgoCD</a></code></h4>
<ul class="">
<li><code><a title="ploigos_step_runner.step_implementers.deploy.argocd.ArgoCD.GIT_REPO_REGEX" href="#ploigos_step_runner.step_implementers.deploy.argocd.ArgoCD.GIT_REPO_REGEX">GIT_REPO_REGEX</a></code></li>
<li><code><a title="ploigos_step_runner.step_implementers.deploy.argocd.ArgoCD.step_implementer_config_defaults" href="#ploigos_step_runner.step_implementers.deploy.argocd.ArgoCD.step_implementer_config_defaults">step_implementer_config_defaults</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>